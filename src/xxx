auxiliary.cc-    sign = factor_sign * sign; 
auxiliary.cc:  } while (exp(dummy) > fabs(res) * epsilon);
auxiliary.cc-  return res;
auxiliary.cc-}
auxiliary.cc-
auxiliary.cc-void vectordist(double *v, int *Dim, double *dist, int *diag){
auxiliary.cc-  int m, n, d, l, dim, r, lr, dr, add;
--
auxiliary.cc-    right=end+1;   
auxiliary.cc:    while (left < right) {      
auxiliary.cc:      while (++left < right && smaller(pos[left], pivot)) pivotpos++;
auxiliary.cc:      while (--right > left && greater(pos[right], pivot));      
auxiliary.cc-      if (left < right) {
auxiliary.cc-	swap=pos[left]; pos[left]=pos[right]; pos[right]=swap;
auxiliary.cc-	pivotpos++;
auxiliary.cc-      }
auxiliary.cc-    }
--
avltr.cc-	  /* T2. */
avltr.cc:	  while (p != NULL)
avltr.cc-	    {
avltr.cc-	      /* T3. */
avltr.cc-	      ab[ap] = 0;
avltr.cc-	      an[ap++] = p;
avltr.cc-	      p = p->link[0];
--
avltr.cc-	{
avltr.cc:	  while (p->rtag == MINUS)
avltr.cc-	    {
avltr.cc-	      p = p->link[1];
avltr.cc-	      q = q->link[1];
avltr.cc-	    }
avltr.cc-	  p = p->link[1];
--
avltr.cc-	/* T2. */
avltr.cc:	while (tp != NULL)
avltr.cc-	  {
avltr.cc-	    /* T3. */
avltr.cc-	    *ap++ = tp;
avltr.cc-	    tp = tp->link[0];
avltr.cc-	  }
--
avltr.cc-	  p = p->link[1];
avltr.cc:	  while (p->link[0] != NULL)
avltr.cc-	    p = p->link[0];
avltr.cc-	}
avltr.cc-
avltr.cc-      if (p == &tree->root)
avltr.cc-	return;
--
avltr.cc-      p = p->link[1];
avltr.cc:      while (p->link[0] != NULL)
avltr.cc-	p = p->link[0];
avltr.cc-    }
avltr.cc-
avltr.cc-  if (p == &tree->root)
avltr.cc-    {
--
avltr.cc-      p = p->link[1];
avltr.cc:      while (p->link[0] != NULL)
avltr.cc-	p = p->link[0];
avltr.cc-    }
avltr.cc-
avltr.cc-  if (p == &tree->root)
avltr.cc-    return NULL;
--
avltr.cc-  r = p = s->link[(int) s->cache];
avltr.cc:  while (p != q)
avltr.cc-    {
avltr.cc-      p->bal = p->cache * 2 - 1;
avltr.cc-      p = p->link[(int) p->cache];
avltr.cc-    }
avltr.cc-
--
avltr.cc-		avltr_node *s = r->link[0];
avltr.cc:		while (s->rtag == PLUS)
avltr.cc-		  s = s->link[1];
avltr.cc-		assert (s->rtag == MINUS);
avltr.cc-		s->link[1] = r;
avltr.cc-	      }
avltr.cc-	    *q = r;
--
avltr.cc-	    /* D8. */
avltr.cc:	    while (s->link[0] != NULL)
avltr.cc-	      {
avltr.cc-		r = s;
avltr.cc-		s = r->link[0];
avltr.cc-		a[k] = 0;
avltr.cc-		pa[k++] = r;
--
avltr.cc-  /* D10. */
avltr.cc:  while (--k)
avltr.cc-    {
avltr.cc-      avltr_node *const s = pa[k];
avltr.cc-
avltr.cc-      if (a[k] == 0)
avltr.cc-	{
--
avltr.cc-  
avltr.cc:    while (NULL != (data = avltr_next (tree, data)))
avltr.cc-      {
avltr.cc-	if (((int) *data) < last)
avltr.cc-	  {
avltr.cc-	    printf (" Misordered right threads.\n");
avltr.cc-	    abort ();
--
extremes.cc-	invpoisson = 1.0 / poisson;
extremes.cc:	while (control < totalpoints) {   
extremes.cc-	  // the following is essentially the same as the code in MPP.cc!!
extremes.cc-	  // how to reorganise it to get rid of the duplication of the code??
extremes.cc-	  //	  
extremes.cc-	  MppFct(s, min, max, &model); 
extremes.cc-	  if (kc->simugrid) {
--
extremes.cc-	    d = 0; // only needed for assert(d<dim)
extremes.cc:	    while (index[dimM1]<end[dimM1]) {
extremes.cc-	      register double dummy;
extremes.cc-	      assert(d<dim); 
extremes.cc-	      dummy =  model(coord) * invpoisson;
extremes.cc-	      if (RES[resindex] < dummy) RES[resindex]=dummy;
extremes.cc-	      d=0;
--
extremes.cc-	      resindex++;
extremes.cc:	      while (index[d] >= end[d]) { 
extremes.cc-	        if (d>=dimM1) break;  // below not possible
extremes.cc-		//                       as dim==1 will fail!
extremes.cc-		index[d]=start[d];
extremes.cc-		coord[kc->idx[d]] = startcoord[d];
extremes.cc-		resindex -= segmentdelta[d];
--
extremes.cc-	  threshold = s->maxheight * invpoisson;
extremes.cc:	  while ((control<totalpoints) && (RES[control]>=threshold)) control++;
extremes.cc-	  if (GENERAL_PRINTLEVEL>=3) {
extremes.cc-	    counter++;
extremes.cc-	    if ((counter % 100==0) && (control<totalpoints))
extremes.cc-	      PRINTF("%d, %d-th position: value=%f threshold=%f \n",
extremes.cc-		     counter, control, RES[control], threshold); 
extremes.cc-	  }   
extremes.cc:	} // while control < totalpoints
extremes.cc-
extremes.cc-	for (i=0; i<totalpoints; i++) RES[i] *= s->factor;
extremes.cc-      } //v
extremes.cc-    } // for, n
extremes.cc-    PutRNGstate();
--
extremes.cc-           
extremes.cc:      while (true) {
extremes.cc-	for (i=0; i<totalpoints; i++) {// 0, not control, since we approximate
extremes.cc-	  //                     and 0 as starting control increases precision
extremes.cc-	  s->rf[i] *= invpoisson;
extremes.cc-	  if (RES[i] < s->rf[i]) RES[i]=s->rf[i];
extremes.cc-	}
--
extremes.cc-	threshold = s->assumedmax * invpoisson;
extremes.cc:	while ((control<totalpoints) && (RES[control]>=threshold)) {control++;}
extremes.cc-	if (control>=totalpoints) break;
extremes.cc-	if ((*error = internal_DoSimulateRF(&(s->key), 1, s->rf)) != NOERROR)
extremes.cc-	   return;
extremes.cc-	if (GENERAL_PRINTLEVEL>=3) {
extremes.cc-	  counter++;
--
extremes.cc-	}
extremes.cc:      } // while
extremes.cc-      
extremes.cc-      for (i=0; i<totalpoints; i++) RES[i] *= s->inv_mean_pos;
extremes.cc-    } // for, n
extremes.cc-  }
extremes.cc-  return;
--
MPP.cc-      d = 0; // only needed for assert(d<dim)
MPP.cc:      while (index[dimM1] < end[dimM1]) {
MPP.cc-	assert(d<timespacedim); 
MPP.cc-	res[resindex] += model(coord); 
MPP.cc-	d=0;
MPP.cc-	index[d]++;
MPP.cc-	coord[kc->idx[d]] += kc->x[XSTEPD[d]];
MPP.cc-	resindex++;
MPP.cc:	while (index[d] >= end[d]) { 
MPP.cc-	  if (d>=dimM1) break;  // below not possible
MPP.cc-	  //                       as dim==1 will fail!
MPP.cc-	  index[d] = start[d];
MPP.cc-	  coord[kc->idx[d]] = startcoord[d];
MPP.cc-	  resindex -= segmentdelta[d];
--
RFcircembed.cc- /* The algorithm below:
RFcircembed.cc:  while (!positivedefinite && (trials<cepar->trials)){
RFcircembed.cc-    trials++;
RFcircembed.cc-    calculate the covariance values "c" according to the given "m"
RFcircembed.cc-    fastfourier(c)
RFcircembed.cc-    if (!cepar->force || (trials<cepar->trials)) {
RFcircembed.cc-      check if positive definite
--
RFcircembed.cc-  trials=0;
RFcircembed.cc:  while (!positivedefinite && (trials<cepar->trials)){ 
RFcircembed.cc-    trials++;
RFcircembed.cc-    cumm[0]=1; 
RFcircembed.cc-    for(i=0;i<dim;i++){
RFcircembed.cc-      halfm[i]=mm[i]/2; 
RFcircembed.cc-      index[i]=1-halfm[i]; 
--
RFcircembed.cc-      c[dummy+1] = 0.0;
RFcircembed.cc:      k=0; while( (k<dim) && (++(index[k]) >= mm[k])) {
RFcircembed.cc-	index[k]=0;
RFcircembed.cc-	k++;
RFcircembed.cc-      }
RFcircembed.cc-      assert( (k<dim) || (i==mtot-1));
RFcircembed.cc-    }
--
RFcircembed.cc-      // 16.9. < cepar.tol.im  changed to <=
RFcircembed.cc:      while ((twoi<mtot2) && (positivedefinite=(c[twoi]>=cepar->tol_re) && 
RFcircembed.cc-					  (fabs(c[twoi+1])<=cepar->tol_im)))
RFcircembed.cc-	{twoi+=2;}      
RFcircembed.cc-
RFcircembed.cc-      if ( !positivedefinite) {
RFcircembed.cc-        if (GENERAL_PRINTLEVEL>=2)
--
RFcircembed.cc-      //	PREFERENCE[hyper->localtype]!=sc->nr) continue; 
RFcircembed.cc:      while ((msg = hyper->getparam(sc + 1, sc->param, instance++))
RFcircembed.cc-	     != MSGLOCAL_ENDOFLIST) {
RFcircembed.cc-//	printf("%d %s %d \n", instance, hyper->name, msg);
RFcircembed.cc-
RFcircembed.cc-	if ((Xerror=
RFcircembed.cc-	     hyper->checkNinit(sc, COVLISTALL, key->ncov - meth->covlist[v], 
--
RFcircembed.cc-	}
RFcircembed.cc:      } // while
RFcircembed.cc-      err =  GetOrthogonalUnitExtensions(kc->aniso, key->timespacedim, grid_ext);
RFcircembed.cc-      if (err != NOERROR) {
RFcircembed.cc-	  // err is extra since Xerror at this stage can be both NOERROR and
RFcircembed.cc-	  // and an error message; the latter could be overwritten by
RFcircembed.cc:	  // NOERROR; Xerror is only of relavance if all loops in while
RFcircembed.cc-	  // fail; so it cannot be changed; see also assert(Xerror!=NOERROR)
RFcircembed.cc-	  // below where consistency is checked.
RFcircembed.cc-	  Xerror=err; 
RFcircembed.cc-	  goto ErrorHandling;
RFcircembed.cc-      }
--
RFcircembed.cc-      k=0;
RFcircembed.cc:      while( (k<dim) && (++index[k]>=key->length[k])) {
RFcircembed.cc-	index[k]=0;
RFcircembed.cc-	x[k] = 0.0;
RFcircembed.cc-	k++;
RFcircembed.cc-      }
RFcircembed.cc-      if (k>=dim) break;
--
RFcircembed.cc-	k++;
RFcircembed.cc:	while((k<dim) && (++index[k]>HalfMaM[free[k]][k])) {
RFcircembed.cc-	  free[k] = true;
RFcircembed.cc-	  index[k]= 0; 
RFcircembed.cc-	  k++;
RFcircembed.cc-	}
RFcircembed.cc-	if (k>=dim) break;
--
RFcircembed.cc-	  k--;
RFcircembed.cc:	  while ( (k>=0) && ((index[k]==0) || (index[k]==halfm[k]))) {
RFcircembed.cc-	    // second and following: index[k] is 0 or halfm?
RFcircembed.cc-	    free[k] = false;
RFcircembed.cc-	  k--;
RFcircembed.cc-	  }
RFcircembed.cc-	}
--
RFcircembed.cc-    k=0; 
RFcircembed.cc:    while(k<dim && (++(s->cur_square[k]) >= s->max_squares[k])) {
RFcircembed.cc-      s->cur_square[k++]=0;
RFcircembed.cc-    }
RFcircembed.cc-    s->new_simulation_next = k==dim; 
RFcircembed.cc-  }
RFcircembed.cc-  //printf("%d %d\n", s->cur_square[0],s->cur_square[1]);
--
RFdirect.cc-      p[d] += step[d];
RFdirect.cc:      while (index[d] >= key->length[d]) { 
RFdirect.cc-	index[d]=0; 
RFdirect.cc-	p[d]=0.0; 
RFdirect.cc-	d++;   // d--;
RFdirect.cc-	assert(d<dim); // assert(d>=0);
RFdirect.cc-	(index[d])++; 
--
RFempvario.cc-	    low=0; up= *nbin; /* 21.2.01, *nbin-1 */  cur= halfnbin;
RFempvario.cc:	    while (low!=up) { 
RFempvario.cc-	      if (distSq> BinSq[cur]) {low=cur;} else {up=cur-1;} /* ( * ; * ] */ 
RFempvario.cc-	      cur=(up+low+1)/2; 
RFempvario.cc-	    }
RFempvario.cc-	    for (segment=0;segment<totalpointsrepet;segment += totalpoints) {
RFempvario.cc-	      double x;
--
RFempvario.cc-	  indextail[d2]++; p2[d2]+=dx[d2];
RFempvario.cc:	  while (indextail[d2]>=gridpoints[d2]) { 
RFempvario.cc-	    indextail[d2]=0; p2[d2]=0; 
RFempvario.cc-	    d2--; 
RFempvario.cc-	    assert(d2>=0); 	
RFempvario.cc-	    indextail[d2]++; p2[d2]+=dx[d2];
RFempvario.cc-	  }
--
RFempvario.cc-	  indexhead[d1]++; p1[d1]+=dx[d1];      
RFempvario.cc:	  while (indexhead[d1]>=gridpoints[d1]) { 
RFempvario.cc-	    indexhead[d1]=0; p1[d1]=0; 
RFempvario.cc-	    d1--;  
RFempvario.cc-	    assert(d1>=0); 
RFempvario.cc-	    indexhead[d1]++; p1[d1]+=dx[d1];
RFempvario.cc-	  }
--
RFempvario.cc-	  for (distSq=0.0,i=0;i<=dimM1;i++) {distSq+=psq[i];}
RFempvario.cc:	  while ((distSq>maxbinsquare)  || (p[d]>maxdist[d])) {/* (*) */ 
RFempvario.cc-	    delta[d]=0; psq[d]=p[d]=0.0; 
RFempvario.cc-	    d++;   
RFempvario.cc-	    if (d<=dimM1) { 
RFempvario.cc-	      delta[d]++; p[d]+=dx[d]; psq[d]=p[d]*p[d];
RFempvario.cc-	      for (distSq=0.0,i=0;i<=dimM1;i++) {distSq+=psq[i];}
--
RFempvario.cc-	  }
RFempvario.cc:	} while ((distSq<=BinSq[0]) && (d<=dimM1));
RFempvario.cc-	if (d>dimM1) break;
RFempvario.cc-	if (GENERAL_PRINTLEVEL>=10) 
RFempvario.cc-	    PRINTF("\n {%d %d %d}",delta[0],delta[1],delta[2]);
RFempvario.cc-	assert((distSq<=BinSq[*nbin]) && (distSq>BinSq[0]));
RFempvario.cc-	{
--
RFempvario.cc-	  low=0; up= *nbin; /* */ cur= halfnbin;
RFempvario.cc:	  while(low!=up){
RFempvario.cc-	    if (distSq> BinSq[cur]) {low=cur;} else {up=cur-1;} /* ( * ; * ] */ 
RFempvario.cc-	    cur=(up+low+1)/2; }
RFempvario.cc-	}	
RFempvario.cc-
RFempvario.cc-	
RFempvario.cc-	i=0; 
RFempvario.cc:	while ((i<dimM1) && (delta[i]==0)) i++; 
RFempvario.cc-	swapstart=i+1;
RFempvario.cc-	
RFempvario.cc-	for(i=0;i<=dimM1;i++) {
RFempvario.cc-	  deltaTwo[i]=delta[i]<<1;
RFempvario.cc-	  DeltaTwoSegmentbase[i] = delta[i] * SegmentbaseTwo[i];
--
RFempvario.cc-	      valuePointhead-= DeltaTwoSegmentbase[d];
RFempvario.cc:	      while ( (indexhead[d]<indextail[d]-delta[d]) || (delta[d]==0)) { 
RFempvario.cc-		if (delta[d]!=0) {
RFempvario.cc-		  // so, indexhead[d]<indextail[d]-delta[d]; 
RFempvario.cc-		  // i.e.indexhead[d]=indextail[d]-3*delta[d]
RFempvario.cc-		  valuePointhead += DeltaFourSegmentbase[d]; 
RFempvario.cc-		  indexhead[d]=indextail[d]+delta[d]; 
--
RFempvario.cc-	    indextail[d]++;  valuePtail+=segmentbase[d];
RFempvario.cc:	    while (indextail[d]>=gridpoints[d]) { 
RFempvario.cc-	      valuePtail -= indextail[d] * segmentbase[d];
RFempvario.cc-	      indextail[d]=0;
RFempvario.cc-	      d++; 
RFempvario.cc-	      if (d<=dimM1) {
RFempvario.cc-		indextail[d]++; valuePtail+=segmentbase[d];
--
RFempvario.cc-	  low=0; up= *nbin; cur= halfnbin;
RFempvario.cc:	  while (low!=up) {  
RFempvario.cc-	    if (distSq> BinSq[cur]) {low=cur;} else {up=cur-1;} // ( * ; * ]  
RFempvario.cc-	    cur=(up+low+1)/2; 
RFempvario.cc-	  } 	
RFempvario.cc-	  for (segment=0;segment<totalpointsrepet;segment += totalpoints) { 
RFempvario.cc-	    double x;
--
RFempvario.cc-  // ii is used in switch by this value: !!!!
RFempvario.cc:  ii=0; while( (ii<=*nbin) && (bin[ii]<0) ){ii++;}
RFempvario.cc-  ii--;
RFempvario.cc-
RFempvario.cc-  // 11.10.03: factor ohne *repet to be clearer
RFempvario.cc-  // case ii : separat behandelt, neu geschrieben
RFempvario.cc-  if (*repet>1) {
--
RFgetNset.cc-    ln=strlen(name[v]);
RFgetNset.cc:    while ( (nr[v] < DISTRNR) && strncmp(name[v], DISTRNAMES[nr[v]], ln)) {
RFgetNset.cc-      (nr[v])++;
RFgetNset.cc-    }
RFgetNset.cc-    if (nr[v]<DISTRNR) { 
RFgetNset.cc-      // a matching function is found. Are there other functions that match?
RFgetNset.cc-      int j; 
--
RFgetNset.cc-      //            the last one is taken 
RFgetNset.cc:      while (j<DISTRNR) {
RFgetNset.cc:	while ( (j<DISTRNR) && strncmp(name[v],DISTRNAMES[j],ln)) {j++;}
RFgetNset.cc-	if (j<DISTRNR) {
RFgetNset.cc-	  if (ln==strlen(DISTRNAMES[j])) {nr[v]=j; exactmatching=true;} 
RFgetNset.cc-	  else {multiplematching=true;}
RFgetNset.cc-	}
RFgetNset.cc-	j++;
--
RFgetNset.cc-    ln=strlen(name[v]);
RFgetNset.cc:    while ( (nr[v]<currentNrCov) && strncmp(name[v],CovList[nr[v]].name,ln)) {
RFgetNset.cc-      (nr[v])++;
RFgetNset.cc-    }
RFgetNset.cc-    if (nr[v]<currentNrCov) { 
RFgetNset.cc-      // a matching function is found. Are there other functions that match?
RFgetNset.cc-      int j; 
--
RFgetNset.cc-      //            the last one is taken 
RFgetNset.cc:      while (j<currentNrCov) {
RFgetNset.cc:	while ( (j<currentNrCov) && strncmp(name[v],CovList[j].name,ln)) {j++;}
RFgetNset.cc-	if (j<currentNrCov) {
RFgetNset.cc-	  if (ln==strlen(CovList[j].name)) {nr[v]=j; exactmatching=true;} 
RFgetNset.cc-	  else {multiplematching=true;}
RFgetNset.cc-	}
RFgetNset.cc-	j++;
--
RFgetNset.cc-    ln=strlen(name[v]);
RFgetNset.cc:    while ( (nr[v]<(int) Forbidden) && strncmp(name[v],METHODNAMES[nr[v]],ln)) {
RFgetNset.cc-      (nr[v])++;
RFgetNset.cc-    }
RFgetNset.cc-    if (nr[v]<(int) Forbidden) { 
RFgetNset.cc-      // a matching method is found. Are there other methods that match?
RFgetNset.cc-      int j; 
--
RFgetNset.cc-      //          taken; stupid here, but nice in GetCovNr
RFgetNset.cc:      while (j<(int) Forbidden) {
RFgetNset.cc:	while ( (j<(int) Forbidden) && strncmp(name[v],METHODNAMES[j],ln)) j++;
RFgetNset.cc-	if (j<(int) Forbidden) {
RFgetNset.cc-	  if (ln==strlen(METHODNAMES[j])) {nr[v]=j; exactmatching=true;} 
RFgetNset.cc-	  else {multiplematching=true;}
RFgetNset.cc-	}
RFgetNset.cc-	j++;
--
RFgetNset.cc-	x *= 2.0;
RFgetNset.cc:	while ( (y=cov(&x, oldp, 1)) > 0.05) {  
RFgetNset.cc-	  if (yold<y){ wave++;  if (wave>10) {*error=ERRORWAVING; return;} }
RFgetNset.cc-	  yold = y;
RFgetNset.cc-	  x *= 2.0;
RFgetNset.cc-	  if (x>1E30) {*error=ERRORRESCALING; return;} // or use a separate ERROR
RFgetNset.cc-	} 
--
RFgetNset.cc-	x *= 0.5;
RFgetNset.cc:	while ( (y=cov(&x, oldp, 1)) < 0.05) {  
RFgetNset.cc-	  if (yold>y){ wave++;  if (wave>10) {*error=ERRORWAVING; return;} }
RFgetNset.cc-	  yold = y;
RFgetNset.cc-	  x *= 0.5;
RFgetNset.cc-	  if (x<1E-30) {*error=ERRORRESCALING; return;} //or use a separate ERROR
RFgetNset.cc-	}    
--
RFgetNset.cc-    if (i!=endforM1)
RFgetNset.cc:      while(j[k]>=2) { assert(j[k]==2); j[k]=0;  k++; (j[k])++;}	
RFgetNset.cc-  }
RFgetNset.cc-  endfor *= key->timespacedim;
RFgetNset.cc-  for (index=l=0; index<endfor; index+=key->timespacedim) {
RFgetNset.cc-    for (n=k=0; k<Stimespacedim; k++) {
RFgetNset.cc-      register double dummy;
--
RFgetNset.cc-    if (i!=endforM1)
RFgetNset.cc:      while(j[k]>=2) { assert(j[k]==2); j[k]=0;  k++; (j[k])++;}	
RFgetNset.cc-  }
RFgetNset.cc-  endfor *= timespacedim;
RFgetNset.cc-  for (index=l=0; index<endfor; index+=timespacedim) {
RFgetNset.cc-    n = 0;
RFgetNset.cc-    for (k=0; k<keycov->truetimespacedim; k++) {
--
RFgetNset.cc-  for (i = 0; i < nf; i++)
RFgetNset.cc:    while(n % f[i] == 0) if ((n /= f[i]) == 1) return TRUE;
RFgetNset.cc-  return n == 1;
RFgetNset.cc-}
RFgetNset.cc-int nextn(int n, int *f, int nf) // taken from fourier.c of R
RFgetNset.cc-{
RFgetNset.cc:    while(!ok_n(n, f, nf)) { n++; }
RFgetNset.cc-  return n;
RFgetNset.cc-}
RFgetNset.cc-
RFgetNset.cc-bool HOMEMADE_NICEFFT=false;
RFgetNset.cc-unsigned long NiceFFTNumber(unsigned long n) {
--
RFgetNset.cc-    for (i=0; i<F_NUMBERS; i++) 
RFgetNset.cc:      while ( ((n % f[i])==0) && (n>10000)) { m*=f[i]; n/=f[i]; }
RFgetNset.cc-    if (n>10000) {
RFgetNset.cc:      while (n>10000) {m*=10; n/=10;}
RFgetNset.cc-      n++;
RFgetNset.cc-    }
RFgetNset.cc-    min = 10000000;
RFgetNset.cc-    for (i=0, ii=1; i<=14; i++, ii<<=1) { // 2^14>10.000
RFgetNset.cc-      if (ii>=n) { if (ii<min) min=ii; break; }
--
RFnugget.cc-	  nonzero_pos=ANISO;
RFnugget.cc:	  while ((nonzero_pos<endfor) && (first->param[nonzero_pos]==0.0))
RFnugget.cc-	    nonzero_pos++;
RFnugget.cc-	  if (nonzero_pos>=endfor) {
RFnugget.cc-	      Xerror=ERRORTRIVIAL; goto ErrorHandling; 
RFnugget.cc-	  }
RFnugget.cc-	}
--
RFnugget.cc-	(index[d])++; 
RFnugget.cc:	while (index[d] >= key->length[d]) { 
RFnugget.cc-	    printf("%d \n", d);
RFnugget.cc-	  index[d] = 0; 
RFnugget.cc-	  d++;   
RFnugget.cc-	  (index[d])++; 
RFnugget.cc-	}
--
RFsimu.cc-	    y[i] += key->x[i][XSTEP];
RFsimu.cc:	    while(yi[i]>=key->length[i]) {
RFsimu.cc-	      yi[i]=0;
RFsimu.cc-	      y[i] = key->x[i][XSTART];
RFsimu.cc-	      if (i<dimM1) {
RFsimu.cc-	        i++;
RFsimu.cc-		(yi[i])++;
--
RFsimu.cc-  assert(dim==1);
RFsimu.cc:  while (v<ncov) {
RFsimu.cc-    vold = v;
RFsimu.cc:    v++; while ((v<ncov) && keycov[covlist[v-1]].op) v++;
RFsimu.cc-    for (w1=vold; w1<v; w1++) {
RFsimu.cc-      kc = &(keycov[covlist[w1]]);
RFsimu.cc-      cov = &(CovList[kc->nr]);
RFsimu.cc-      z = fabs(x[0] * kc->aniso[0]);
RFsimu.cc-      fct[w1] = kc->param[VARIANCE] * cov->cov(&z, kc->param, dim); 
--
RFsimu.cc-  assert(dim==1);
RFsimu.cc:  while (v<ncov) {
RFsimu.cc-    vold = v;
RFsimu.cc:    v++; while ((v<ncov) && keycov[covlist[v-1]].op) v++;
RFsimu.cc-    for (w=vold; w<v; w++) {
RFsimu.cc-      kc = &(keycov[covlist[w]]);
RFsimu.cc-      cov = &(CovList[kc->nr]);
RFsimu.cc-      z = fabs(x[0] * kc->aniso[0]);
RFsimu.cc-      fct[w] = kc->param[VARIANCE] * cov->cov(&z, kc->param, dim); 
--
RFsimu.cc-  
RFsimu.cc:  while (error != NOERROR) {
RFsimu.cc-    int error_covnr, m;
RFsimu.cc-    error_covnr = NOERROR;
RFsimu.cc-    if (error != ERRORANYLEFT) {
RFsimu.cc-        error_covnr = next_element_of_method_list(key); 
RFsimu.cc-    }
--
RFsimu.cc-	  v=0; 
RFsimu.cc:	  while(key->cov[v].method!=m || !key->cov[v].left) v++;
RFsimu.cc-	  key->ML[v][key->IML[v]] = Nothing; 
RFsimu.cc-//        printf("IML NML %d %d %d %d\n", m,m, NML[0], NML[1]);
RFsimu.cc-	  // es lohnt sich nicht, die Methoden durchzuleiern,
RFsimu.cc-	  // die auf die Kovarianzfunktion bereits angewandt wurden und
RFsimu.cc-	  // diese Kovarianzfunktion dabei die einzige war
--
RFsimu.cc-	// unimeth_alreadyInUse: to avoid that method is called again
RFsimu.cc:	// when next while loop, which would leed to a double i.e. an incorrect
RFsimu.cc-	// memory allocation
RFsimu.cc-//        printf("M NML %d %d %d %d\n", M, key->n_unimeth, key->NML[0], key->NML[1]);
RFsimu.cc-
RFsimu.cc-	bool left[MAXCOV];
RFsimu.cc-	methodvalue_type *meth;
--
RFsimu.cc-    }
RFsimu.cc:  } // while error!=NOERROR
RFsimu.cc-
RFsimu.cc-  //    for (v=0; v<key->ncov; v++) 
RFsimu.cc-//	 printf("*** %d %s %s %d\n", 
RFsimu.cc-//		v, METHODNAMES[key->cov[v].method], 
RFsimu.cc-//		 METHODNAMES[key->ML[v][0]], key->NML[v]);
--
RFsimu.cc-	  kcdummy = kc;
RFsimu.cc:	  while (v + vplus < key->ncov && kcdummy->op) {
RFsimu.cc-	    if (CovList[kcdummy->nr].type==ISOHYPERMODEL || 
RFsimu.cc-		CovList[kcdummy->nr].type==ANISOHYPERMODEL) {
RFsimu.cc-	      // too complicated for the moment; should be improved
RFsimu.cc-	      error = ERRORFAILED;
RFsimu.cc-	      goto ErrorHandling;
--
RFtbm.cc-    
RFtbm.cc:    while (true) {
RFtbm.cc-      n *= 3;
RFtbm.cc-      h = delta / (double) n;
RFtbm.cc-      ineu = 0.0;
RFtbm.cc-      for (k=1, x=b[i]+h; k<n; k++, x+=h) {
RFtbm.cc-	switch (k % 6) {
--
RFtbm.cc-    double z[2]; //'' !! 2 !
RFtbm.cc:    while (v<ncov) {
RFtbm.cc-      vold = v;
RFtbm.cc:      v++; while ((v<ncov) && keycov[covlist[v-1]].op) v++; 
RFtbm.cc-      zw = 1.0;
RFtbm.cc-      for (w=vold; w<v; w++) { 
RFtbm.cc-	// there could be multiplication by pure time components (z[0]=0)!
RFtbm.cc-	kc = &(keycov[covlist[w]]);
RFtbm.cc-        cov = &(CovList[kc->nr]);
--
RFtbm.cc-  if (dim==2) { // => s->anisotropy! 
RFtbm.cc:    while (v<ncov) {
RFtbm.cc-      vold = v;
RFtbm.cc:      v++; while ((v<ncov) && keycov[covlist[v-1]].op) v++;
RFtbm.cc-      zw = 1.0;
RFtbm.cc-      for (w=vold; w<v; w++) {
RFtbm.cc-	kc = &(keycov[covlist[w]]);
RFtbm.cc-        cov = &(CovList[kc->nr]);
RFtbm.cc-	z[0] = kc->aniso[0] * x[0];
--
RFtbm.cc-	    kc->truetimespacedim == 1 + tbm_dim;
RFtbm.cc:	while (!ce_dim2 && (++v)<key->ncov && kc->op) {
RFtbm.cc-	  // here: only check whether within the multiplicative model
RFtbm.cc-	  // the anisotropy matrices are not multiplicatives of each other.
RFtbm.cc-	  // If so, ce_dim2 is necessarily true.
RFtbm.cc-	  // At this point it is not checked whether the matrix combinations
RFtbm.cc-	  // are allowed ones.
--
RFtbm.cc-	  kc->left = true;
RFtbm.cc:	  while (actcov>0 && key->cov[meth->covlist[actcov-1]].op) {
RFtbm.cc-	      key->cov[meth->covlist[actcov-1]].left = true;
RFtbm.cc-	      actcov--;
RFtbm.cc-	  }
RFtbm.cc-	  assert(actcov>=0);
RFtbm.cc:	  while (v<key->ncov && key->cov[v].op) v++;  
RFtbm.cc-	  continue;
RFtbm.cc-      }
RFtbm.cc-      Xerror=cov->check(kc->param, tbm_dim + (int) ce_dim2, method);
RFtbm.cc-      if (Xerror && (Xerror!=ERRORCOVNUMERICAL || method!=TBM2 || !TBM2NUMERIC))
RFtbm.cc-	goto ErrorHandling;
--
RFtbm.cc-	kc->left = true;
RFtbm.cc:	while (actcov>0 && key->cov[meth->covlist[actcov-1]].op) {
RFtbm.cc-	  key->cov[meth->covlist[actcov-1]].left = true;
RFtbm.cc-	  actcov--;
RFtbm.cc-	}
RFtbm.cc-	if (actcov==0) { Xerror=ERRORANISOMIX; goto ErrorHandling; }
RFtbm.cc:	while (v<key->ncov && key->cov[v].op) v++;  
RFtbm.cc-	continue;
RFtbm.cc-      }
RFtbm.cc-    
RFtbm.cc-      int kappas;
RFtbm.cc-      kappas = cov->kappas(1);
--
RFtbm.cc-   memcpy(&CIRCEMBED, &TBMCE, sizeof(ce_param));
RFtbm.cc:   while (tbm_method != Forbidden) {
RFtbm.cc-     int tbmmethod[MAXCOV], i;
RFtbm.cc-     for (i=0; i<meth->actcov; i++) tbmmethod[i]=tbm_method;
RFtbm.cc-
RFtbm.cc-     //   printf("tbm %d %d\n", covnr[0], meth->actcov);
RFtbm.cc-
--
Xempvario.cc-	phidata = NEARBYINT(atan2(delta[1], delta[0]) - startphi);
Xempvario.cc:	while (phidata < 0) phidata += TWOPI;
Xempvario.cc:	while (phidata >= TWOPI) phidata -= TWOPI;
Xempvario.cc-	kphi = *nbin * (int) (phidata * invsegphi);
Xempvario.cc-
Xempvario.cc-
Xempvario.cc-	for (iz=mini[2]; iz <= maxi[2]; iz++) {
Xempvario.cc-	  delta[2] = iz * step[2];
--
Xempvario.cc-	    low=0; up= *nbin; /* */ cur= halfnbin;
Xempvario.cc:	    while(low!=up){
Xempvario.cc-	      if (psq[2] > BinSq[cur]) {low=cur;} else {up=cur-1;}/*( . ; . ]*/ 
Xempvario.cc-	      cur=(up+low+1)/2;
Xempvario.cc-	    }
Xempvario.cc-	  }	// low
Xempvario.cc-
--
Xempvario.cc-	  thetadata = NEARBYINT(atan2(delta[2], sqrt(psq[1])) - starttheta);
Xempvario.cc:	  while (thetadata < 0) thetadata += PI; 
Xempvario.cc:	  while (thetadata >= PI) thetadata -= PI;
Xempvario.cc-	  ktheta = (int) (thetadata * invsegtheta);
Xempvario.cc-	  
Xempvario.cc-	  low += kphi + ktheta * twoNphiNbin;
Xempvario.cc-
Xempvario.cc-	  for (deltaT=0, it=low; deltaT<=nstepTstepT; 
--
Xempvario.cc-	  low=0; up=*nbin; cur=halfnbin;
Xempvario.cc:	  while (low!=up) {
Xempvario.cc-	    if (distSq> BinSq[cur]) {low=cur;} else {up=cur-1;} // ( * ; * ]  
Xempvario.cc-	    cur=(up+low+1)/2; 
Xempvario.cc-	  }
Xempvario.cc-
Xempvario.cc-	  // angles
Xempvario.cc-	  phidata = NEARBYINT(atan2(dx[1], dx[0]) - startphi);
Xempvario.cc:	  while (phidata < 0) phidata += TWOPI;
Xempvario.cc:	  while (phidata >= TWOPI) phidata -= TWOPI;
Xempvario.cc-	  kphi = *nbin * (int) (phidata * invsegphi);
Xempvario.cc-
Xempvario.cc-	  thetadata = NEARBYINT(atan2(dx[2], zylinderradius) - starttheta);
Xempvario.cc:	  while (thetadata < 0) thetadata += PI; 
Xempvario.cc:	  while (thetadata >= PI) thetadata -= PI;
Xempvario.cc-	  ktheta = (int) (thetadata * invsegtheta);
Xempvario.cc-
Xempvario.cc-	  low += kphi + twoNphiNbin * ktheta;
Xempvario.cc-	  assert(low>=0 && low<totalspatialbins);
Xempvario.cc-	  
