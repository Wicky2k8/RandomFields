extremes.cc:  if (key->TrendModus != TREND_MEAN) {
extremes.cc:    for (v=0; v<*ncov; v++) key->cov[v].method = MaxMpp;
extremes.cc:    for (m=0; m<key->n_unimeth; m++) key->meth[m].unimeth = MaxMpp;
extremes.cc:    n = key->n_unimeth - 1;
extremes.cc:    s = (mpp_storage*) key->meth[n].S;  
extremes.cc:    s->factor = s->effectivearea / (s->integralpos * (double) (key->n_unimeth));
extremes.cc:      s = (mpp_storage*) key->meth[v].S;  
extremes.cc:      sp1 = (mpp_storage*) key->meth[v+1].S;  
extremes.cc:    key->active=false;
extremes.cc:    meth = &(key->meth[0]);      
extremes.cc:    key->distribution = *distr;
extremes.cc:	     // pnorm(meanDsigma, key->mean, sigma,1,0));
extremes.cc:    key->totalpoints = s->key.totalpoints;// DoSimulateRF regards whether
extremes.cc:    //                                       key->totalpoints is initialised
extremes.cc:	 (double*) malloc(sizeof(double) * key->totalpoints))==NULL) {
extremes.cc:    key->totalpoints = s->key.totalpoints;
extremes.cc:    key->spatialdim = s->key.spatialdim;
extremes.cc:    key->timespacedim = s->key.timespacedim;
extremes.cc:    for (d=0; d<key->timespacedim; d++) key->length[d] = s->key.length[d];
extremes.cc:    key->grid = s->key.grid;
extremes.cc:    key->meth[0].unimeth = key->cov[0].method = ExtremalGauss;
extremes.cc:    key->n_unimeth = 1;
extremes.cc:    key->meth[0].actcov = 0; 
extremes.cc:    key->storing = GENERAL_STORING;
extremes.cc:    key->active = true;
extremes.cc:  key->active=false;
extremes.cc:  if (!key->active) {*error=ERRORNOTINITIALIZED; goto ErrorHandling;}
extremes.cc:  totalpoints = key->totalpoints;
extremes.cc:  if (key->cov[0].method == (int) MaxMpp) {
extremes.cc:    actcov = key->n_unimeth;
extremes.cc:    assert(actcov == key->ncov);
extremes.cc:    for (segment[0] = 1, d = 0; d < key->timespacedim; d++)// used if simugrid
extremes.cc:      segment[d + 1] = segment[d] * key->length[d];
extremes.cc:    for (RES = res, ni=0; ni<*n; ni++, RES += key->totalpoints) {
extremes.cc:	meth = &(key->meth[m]); 
extremes.cc:	keycov = &(key->cov[meth->covlist[m]]);
extremes.cc:	      if (end[d] > key->length[d]) end[d] = key->length[d];
extremes.cc:    if (key->distribution!=DISTR_MAXSTABLE) {
extremes.cc:    s = (extremes_storage*) key->meth[0].S;
extremes.cc:    for (RES = res, ni=0; ni<*n; ni++, RES += key->totalpoints) {
extremes.cc:      if (!key->active){ *error=ERRORNOTINITIALIZED; goto InternalErrorHandling;}
extremes.cc:  key->active=GENERAL_STORING && key->storing;
extremes.cc:  if (key!=NULL) key->active=false;  
MPP.cc:  * noch fast alles auf key->x programmiert statt s->x
MPP.cc:  meth = &(key->meth[m]);
MPP.cc:  for (actcov=v=0; v<key->ncov; v++) {
MPP.cc:    keycov = &(key->cov[v]);
MPP.cc:      if (key->Time && !keycov->genuine_last_dimension && 
MPP.cc:      if ((v<key->ncov-1 &&  keycov->op)) {
MPP.cc:  keycov = &(key->cov[0]);
MPP.cc:    timespacedim = key->timespacedim;
MPP.cc:      s->length[d]= keycov->x[XSTEPD[d]] * (double) (key->length[d] - 1);
MPP.cc:    keycov = &(key->cov[meth->covlist[v]]);
MPP.cc:    for (ix=i=0; i<key->totalpoints; i++, ix+=timespacedim) {
MPP.cc:  keycov = &(key->cov[meth->covlist[v]]);
MPP.cc:  if (key->anisotropy) return NOERROR_REPEAT;
MPP.cc:  assert(key->active);
MPP.cc:  meth = &(key->meth[m]);
MPP.cc:    for (i=key->totalpoints - 1; i>=0; res[i--]=0.0);
MPP.cc:  switch (key->distribution) {
MPP.cc:    keycov = &(key->cov[meth->covlist[v]]);
MPP.cc:    keycov = &(key->cov[meth->covlist[v]]);
MPP.cc:    if (key->mean!=0) {
MPP.cc:  for (d=0; d<key->timespacedim; d++)  
MPP.cc:      segment[d+1] = segment[d] * key->length[d];
MPP.cc:  for (i=0; i<key->totalpoints; i++) res[i]=0.0;
MPP.cc:  keycov = &(key->cov[meth->covlist[v]]);
MPP.cc:  timespacedim = keycov->simugrid ? key->timespacedim : keycov->truetimespacedim;
MPP.cc:	if (end[d] > key->length[d]) end[d] = key->length[d];	 
MPP.cc:    } else { // !key->simugrid
MPP.cc:      for (j=i=0; i<key->totalpoints; i++) {
MPP.cc:  if (key->distribution==DISTR_GAUSS) {
MPP.cc:    for (i=0; i<key->totalpoints;i++) {
RFcircembed.cc:  meth = &(key->meth[m]);
RFcircembed.cc:  if (!key->grid) {Xerror=ERRORMETHODNOTALLOWED;goto ErrorHandling;}
RFcircembed.cc:  for (d=0; d<key->timespacedim; d++) {
RFcircembed.cc:    s->nn[d]=key->length[d]; 
RFcircembed.cc:    steps[d]=key->x[d][XSTEP];
RFcircembed.cc:  dim = key->timespacedim;
RFcircembed.cc:	 key->covFct(hx, dim, key->cov, meth->covlist, actcov, key->anisotropy); 
RFcircembed.cc:	    cc = fabs(key->covFct(hx, dim, key->cov, meth->covlist, actcov,
RFcircembed.cc:			     key->anisotropy)); 
RFcircembed.cc:  if (key->storing) {
RFcircembed.cc:  if (key->anisotropy) { // code can be reduced to the anisotropic case
RFcircembed.cc:    ncorner_dim = (1 << key->timespacedim) * dim;
RFcircembed.cc:    for (d=0; d<key->timespacedim; d++) {
RFcircembed.cc:      dummy = key->x[d][XSTEP] * (double) (key->length[d] - 1) * kc->aniso[0];
RFcircembed.cc:  if (key->covFct != CovFct) { Xerror=ERRORNOTPROGRAMMED; goto ErrorHandling;}
RFcircembed.cc:  if (!key->grid) { Xerror=ERRORMETHODNOTALLOWED; goto ErrorHandling;}
RFcircembed.cc:  meth = &(key->meth[m]);
RFcircembed.cc:  n_aniso = key->anisotropy ? key->timespacedim * key->timespacedim : 1;
RFcircembed.cc:  for (i=0; i<key->timespacedim; i++) rawRmax[i] = 0.0;
RFcircembed.cc:    kc = &(key->cov[meth->covlist[v]]);
RFcircembed.cc:	     hyper->checkNinit(sc, COVLISTALL, key->ncov - meth->covlist[v], 
RFcircembed.cc:      err =  GetOrthogonalUnitExtensions(kc->aniso, key->timespacedim, grid_ext);
RFcircembed.cc:      for (i=0; i<key->timespacedim; i++) {
RFcircembed.cc:	    (grid_ext[i] * (double) (key->length[i] - 1) * key->x[i][XSTEP]);
RFcircembed.cc://	       key->length[i], key->x[i][XSTEP]);
RFcircembed.cc:    kappas = CovList[sc->nr].kappas(key->timespacedim);
RFcircembed.cc:  for (i=0; i<key->timespacedim; i++) {
RFcircembed.cc:    Xerror = internal_InitSimulateRF(key->x[0], key->T, key->spatialdim,
RFcircembed.cc:				     3, key->grid, key->Time,
RFcircembed.cc:				     simuactcov, key->anisotropy, op,
RFcircembed.cc:  dimsq = key->timespacedim * key->timespacedim;
RFcircembed.cc:      if (key->anisotropy) { // distinction necessary,
RFcircembed.cc:	for (i=0; i<dimsq; i += key->timespacedim + 1) 
RFcircembed.cc:  assert(key->active);
RFcircembed.cc:  s = (localCE_storage*) key->meth[m].S;
RFcircembed.cc:  dim = key->timespacedim;
RFcircembed.cc:  for (k=0; k<key->timespacedim; k++) {
RFcircembed.cc:    for (k=0; k<dim; k++) dx[k] *= key->x[k][XSTEP];
RFcircembed.cc:      while( (k<dim) && (++index[k]>=key->length[k])) {
RFcircembed.cc:  s = (CE_storage*)key->meth[m].S;
RFcircembed.cc:  assert(key->active);
RFcircembed.cc:    assert(!key->storing);
RFcircembed.cc:    assert(key->storing);
RFcircembed.cc:     Warning! If key->storing==false when calling init_circ_embed
RFcircembed.cc:     and key->storing==true when calling do_circ_embed, the
RFcircembed.cc:     the value of key->storing
RFcircembed.cc:  dim = key->timespacedim;
RFcircembed.cc:  int totpts = key->totalpoints;
RFdirect.cc:      dim=key->timespacedim; bool freexx=false;
RFdirect.cc:  meth = &(key->meth[m]);
RFdirect.cc:  totpnts = key->totalpoints;
RFdirect.cc:  if (key->grid) {
RFdirect.cc:      step[d]=key->x[d][XSTEP];
RFdirect.cc:      while (index[d] >= key->length[d]) { 
RFdirect.cc:    if (key->Time) {
RFdirect.cc:      spatialdim = key->spatialdim;
RFdirect.cc:      endfor = key->length[spatialdim]; 
RFdirect.cc:      step = key->T[XSTEP];
RFdirect.cc:      for (t=0, i=0, time=key->T[XSTART]; t<endfor; t++, time += step) 
RFdirect.cc:	for (j=0; j < key->length[0]; j++, i++) {
RFdirect.cc:	  for (d=0; d<spatialdim; d++) xx[d][i]=key->x[d][j];
RFdirect.cc:      for (i=0; i<dim; i++) xx[i] = key->x[i];
RFdirect.cc:	  key->covFct(y, dim, key->cov, meth->covlist, actcov, key->anisotropy);
RFdirect.cc:  assert(key->active);
RFdirect.cc:  S = (direct_storage*) key->meth[m].S;
RFdirect.cc:  totpnts = key->totalpoints;
RFgetNset.cc:	key->mean = *lambda;
RFgetNset.cc:	key->LinearTrend = (double *) malloc(len = sizeof(double) * *ll);
RFgetNset.cc:	memcpy(key->LinearTrend, lambda, len);
RFgetNset.cc:	key->lLinTrend = *ll;
RFgetNset.cc:	key->TrendFunction = (char *) malloc(len = sizeof(char) * *lt);
RFgetNset.cc:	memcpy(key->TrendFunction, *trend, len);
RFgetNset.cc:	key->lTrendFct = *lt;
RFgetNset.cc:      default: key->TrendModus = -1; *error=ERRORUNSPECIFIED; goto ErrorHandling;
RFgetNset.cc:  key->TrendModus = *modus;
RFgetNset.cc:  if (!key->active) {*modus=-3; goto ErrorHandling;}
RFgetNset.cc:  *modus = key->TrendModus;
RFgetNset.cc:  *lt = key->lTrendFct;
RFgetNset.cc:  *ll = key->lLinTrend;
RFgetNset.cc:  *lx = key->totalpoints;
RFgetNset.cc:  if (!key->active) {*error=-3; goto ErrorHandling;}
RFgetNset.cc:  switch(key->TrendModus){
RFgetNset.cc:    memcpy(lambda, key->LinearTrend, key->lLinTrend);
RFgetNset.cc:    if (key->TrendModus==1) break; 
RFgetNset.cc:    strcpy(*trend, key->TrendFunction);
RFgetNset.cc:  if (!key->active) {*error=-3; goto ErrorHandling;}
RFgetNset.cc:  if (key->TrendModus==0) {*error=-4; goto ErrorHandling;}
RFgetNset.cc:  if (!key->active) {*total=-2;} 
RFgetNset.cc:    *total=key->totalpoints;
RFgetNset.cc:    *spatialdim = key->spatialdim;
RFgetNset.cc:    *timespacedim = key->timespacedim;
RFgetNset.cc:    for (d=0; d<MAXDIM; d++) lengths[d]=key->length[d];
RFgetNset.cc:    *grid = (int) key->grid;
RFgetNset.cc:    *distr = (int) key->distribution; 
RFgetNset.cc:  totpts = key->totalpoints;
RFgetNset.cc:  tsdim = key->timespacedim;
RFgetNset.cc:  PROTECT(method = allocVector(VECSXP, key->n_unimeth));
RFgetNset.cc:  for (i=0; i<key->n_unimeth; i++) {
RFgetNset.cc:    meth = &(key->meth[i]);
RFgetNset.cc:	      SET_VECTOR_ELT(S, k++, Num(s->diag, key->timespacedim));
RFgetNset.cc:	  dim = key->grid ? tsdim : 1;
RFgetNset.cc:	    for (i=0; i<dim; i++) INTEGER(dummy)[i] = key->length[i];
RFgetNset.cc:  actninfo = (key->active || ignore_active) ? ninfo : 1;
RFgetNset.cc:  SET_VECTOR_ELT(info, ni++, ScalarLogical(key->active));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarLogical(key->anisotropy)); 
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarLogical(key->compatible)); 
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarLogical(key->grid)); 
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarLogical(key->storing)); 
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarLogical(key->Time)); 
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, mkString(DISTRNAMES[key->distribution]));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger(key->timespacedim));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger(key->totalparam));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger(key->spatialdim));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger(key->TrendModus));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger((int) key->spatialtotalpoints));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarInteger((int) key->totalpoints));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, ScalarReal(key->mean));
RFgetNset.cc:    SET_VECTOR_ELT(info, ni++, GetModelInfo(key->cov, key->ncov, key->totalparam,
RFgetNset.cc:					    key->totalpoints));
RFgetNset.cc:		   GetMethodInfo(key, key->meth, ignore_active, depth));
RFgetNset.cc:  endfor = 1 << key->timespacedim;
RFgetNset.cc:  for (i=0; i<key->timespacedim; i++) j[i]=0;
RFgetNset.cc:    for (k=0; k<key->timespacedim; k++) {
RFgetNset.cc:      sx[index] = key->x[k][XSTART];
RFgetNset.cc:	sx[index] += key->x[k][XSTEP] * (double) (key->length[k] - 1);
RFgetNset.cc:  endfor *= key->timespacedim;
RFgetNset.cc:  for (index=l=0; index<endfor; index+=key->timespacedim) {
RFgetNset.cc:      for (g=0; g<key->timespacedim; g++) 
RFgetNset.cc:      lx[d] = x[XSTEPD[d]] * (double) (key->length[d] - 1);
RFgetNset.cc://	     key->length[d], x[XSTEPD[d]], lx[d]);
RFgetNset.cc:    if (key->grid) { // key->grid     
RFgetNset.cc:      endfor = (1 << key->timespacedim) * truetimespacedim;
RFgetNset.cc:    } else { // not key->grid
RFgetNset.cc:      endfor = key->totalpoints * truetimespacedim;
RFgetNset.cc:  endfor = 1 << key->timespacedim;
RFhyperplan.cc:  meth = &(key->meth[m]);
RFhyperplan.cc:  for (v=0; v <key->ncov; v++) {
RFhyperplan.cc:    kc = &(key->cov[v]);
RFhyperplan.cc:      if ((key->ncov>v+1 && kc->op) || 
RFhyperplan.cc:	  (v>0 && key->cov[v-1].op)) {
RFhyperplan.cc:  if (v==key->ncov) { /* no covariance for the considered method found */
RFhyperplan.cc:  if (key->anisotropy) return NOERROR_REPEAT;
RFhyperplan.cc:  assert(key->active);
RFhyperplan.cc:  meth = &(key->meth[m]);
RFhyperplan.cc:  kc = &(key->cov[meth->covlist[0]]);
RFhyperplan.cc:  variance = key->cov[meth->covlist[0]].param[VARIANCE];
RFhyperplan.cc:  switch (key->distribution) {
RFhyperplan.cc:  if (add) for (i=0; i<key->totalpoints; res[i++]=0.0);
RFhyperplan.cc:    for (i=0; i<key->totalpoints; res[i++]=R_NegInf);
RFhyperplan.cc:	    for (gy=kc->x[XSTARTD[1]], resindex=j=0; j<key->length[1]; j++) {
RFhyperplan.cc:	      for (gx= kc->x[XSTARTD[0]], i=0; i<key->length[0]; i++,
RFhyperplan.cc:	    for (j=resindex=0; resindex<key->totalpoints; resindex++) {
RFhyperplan.cc:  switch (key->distribution) {
RFhyperplan.cc:      for(i=0; i<key->totalpoints; i++) 
RFnugget.cc:  if (key->covFct != CovFct) { Xerror=ERRORNOTPROGRAMMED; goto ErrorHandling;}
RFnugget.cc:  meth = &(key->meth[m]);
RFnugget.cc:  for (v=0; v<key->ncov; v++) {
RFnugget.cc:    kc = &(key->cov[v]);
RFnugget.cc://    printf("nugget %d %d %d %s \n", v, kc->nr, key->ncov, CovList[kc->nr].name);
RFnugget.cc:	if (key->cov[v-1].op) {
RFnugget.cc:	  if (key->cov[v-1].method != Nugget) { // v-1 !!
RFnugget.cc:		      v, key->cov[v-1].op, key->ncov, key->cov[v-1].method,
RFnugget.cc:		      METHODNAMES[key->cov[v-1].method],
RFnugget.cc:      if (key->anisotropy) {
RFnugget.cc:	endfor = key->totalparam;
RFnugget.cc:	// if (key->Time && TIMEEXCEPTION) endfor -= key->timespacedim;
RFnugget.cc:	    if (key->cov[v-1].op) { Xerror=ERRORANISOMIX; goto ErrorHandling; }
RFnugget.cc:  kc = &(key->cov[meth->covlist[0]]);
RFnugget.cc:  s->simple = key->timespacedim == kc->truetimespacedim;
RFnugget.cc:  if (key->anisotropy && !s->simple) {
RFnugget.cc:      int d, dim=key->timespacedim + 1;
RFnugget.cc:      for (d=i=0; d<key->timespacedim; d++, i+=dim) {
RFnugget.cc:        s->reduced_dim[d] =(fabs(s->diag[d]) < NUGGET_TOL)? 1 : key->length[d];
RFnugget.cc:					  s->prod_dim[key->timespacedim])) 
RFnugget.cc:      if ((pos = (int*) malloc(sizeof(int) * key->totalpoints))==0) {
RFnugget.cc:      ordering(kc->x, key->totalpoints, kc->truetimespacedim, pos);
RFnugget.cc:      for (i=1 /* ! */; i<key->totalpoints; i++) {
RFnugget.cc:  nugget_effect = CovFct(ZERO, 1, key->cov, key->meth[m].covlist, actcov, false);
RFnugget.cc:  if (key->anisotropy) return NOERROR_REPEAT;
RFnugget.cc:  meth = &(key->meth[m]);
RFnugget.cc:    for (nx=0, endfor=key->totalpoints; nx<endfor; nx++)
RFnugget.cc:      totpnts = key->totalpoints;
RFnugget.cc:      dim = key->timespacedim;
RFnugget.cc:	while (index[d] >= key->length[d]) { 
RFnugget.cc:      for (nx=0; nx<key->totalpoints; nx++) {
RFother.cc:   //  calls key->initother
RFother.cc:  // do_special calls key->other      
RFother.cc:    endfor = key->totalpoints;
RFsimu.cc:  meth = &(key->meth[m]);
RFsimu.cc:  for (v=0; v<key->ncov; v++) {
RFsimu.cc:    keycov = &(key->cov[v]);
RFsimu.cc:	  error = cov->checkNinit(keycov, COVLISTALL, key->ncov - v - 1,
RFsimu.cc://      printf("v=%d %d %d \n", v,  key->ncov, key->cov[v].op);
RFsimu.cc:      if (v < key->ncov -1 && key->cov[v].op) { 
RFsimu.cc:	if (key->cov[v+1].method != Method) {
RFsimu.cc:		     v, key->cov[v-1].op, key->ncov, key->cov[v-1].method,
RFsimu.cc:		     METHODNAMES[key->cov[v-1].method],
RFsimu.cc:		   v, key->cov[v-1].op, key->ncov, key->cov[v-1],
RFsimu.cc:		   METHODNAMES[key->cov[v-1].method],
RFsimu.cc:  key->active = false;
RFsimu.cc:  key->ncov = key->n_unimeth = 0;
RFsimu.cc:  key->spatialdim = key->timespacedim = key->totalparam = -1;
RFsimu.cc:  key->totalpoints = key->spatialtotalpoints = 0;
RFsimu.cc:    key->meth[m].S = NULL;
RFsimu.cc:    key->meth[m].destruct = NULL;
RFsimu.cc:  COVINFO_NULL(key->cov);
RFsimu.cc:      key->x[d]=NULL;
RFsimu.cc:      key->length[d] = -1;
RFsimu.cc:  key->T[0] = key->T[1] = key->T[2] = 0.0; 
RFsimu.cc:  //    key->naturalscaling =-1;
RFsimu.cc:  key->TrendModus = -1;
RFsimu.cc:  key->TrendFunction = NULL;
RFsimu.cc:  key->LinearTrend = NULL;
RFsimu.cc:  key->mean = 0.0;
RFsimu.cc:  if (key->x[0]!=NULL) free(key->x[0]);
RFsimu.cc:  for (d=0; d<MAXDIM; d++) {key->x[d]=NULL;}
RFsimu.cc:    if (key->cov[m].x != NULL) {
RFsimu.cc:      free(key->cov[m].x);
RFsimu.cc:      key->cov[m].x = NULL;
RFsimu.cc:    if (key->meth[m].destruct!=NULL) {
RFsimu.cc:      key->meth[m].destruct(&(key->meth[m].S));
RFsimu.cc:      key->meth[m].destruct=NULL;
RFsimu.cc:  key->active = false;
RFsimu.cc:  key->ncov = key->n_unimeth = 0;
RFsimu.cc:  key->spatialdim = key->timespacedim = key->totalparam = -1;
RFsimu.cc:  key->totalpoints = key->spatialtotalpoints = 0;
RFsimu.cc:  key->TrendModus = -1;
RFsimu.cc:  if (key->TrendFunction!=NULL) free(key->TrendFunction); 
RFsimu.cc:  key->TrendFunction=NULL;
RFsimu.cc:  if (key->LinearTrend!=NULL) free(key->LinearTrend); 
RFsimu.cc:  key->LinearTrend=NULL;
RFsimu.cc:  key->lTrendFct = 0;
RFsimu.cc:  key->lLinTrend = 0;
RFsimu.cc:  key->active=false;
RFsimu.cc:	 key->grid, key->active, key->anisotropy,
RFsimu.cc:	 key->spatialdim, key->totalpoints,
RFsimu.cc:	 DISTRNAMES[key->distribution], 
RFsimu.cc:	 key->Time, key->T[0], key->T[1], key->T[2], 
RFsimu.cc:	 key->timespacedim, key->compatible,
RFsimu.cc:	 key->ncov);
RFsimu.cc:  for (i=0; i<key->ncov; i++) {
RFsimu.cc:    keycov = &(key->cov[i]);
RFsimu.cc:    for (j=0; j<key->totalparam; j++) PRINTF("%f,", keycov->param[j]);
RFsimu.cc:    if (i < key->ncov - 1) PRINTF("\n%s\n",OP_SIGN[keycov->op]); 
RFsimu.cc:  for (i=0; i<key->ncov; i++) {
RFsimu.cc:    meth = &(key->meth[i]);
RFsimu.cc:  PRINTF("%d : len=%d \n", i, key->length[i]);
RFsimu.cc:  PRINTF("^x=%d ^y=%d ^z=%d \n", key->x[0], key->x[1], key->x[2]);
RFsimu.cc:  keycov = &(key->cov[v]);
RFsimu.cc:     developtime only considered if !key->simugrid && key->Time
RFsimu.cc:  dimM1 = key->timespacedim - 1;
RFsimu.cc:    ? (key->timespacedim * 3)
RFsimu.cc:    : (truetimespacedim * key->totalpoints);
RFsimu.cc://  printf("2nogr %d %d %d %d \n", total, truetimespacedim, simugrid, key->totalpoints);
RFsimu.cc:  if (key->anisotropy) {
RFsimu.cc:    if (key->Time && !key->grid) { // time component, no grid
RFsimu.cc:      endtime =  key->length[key->spatialdim]; 
RFsimu.cc:      for (j=0, t=key->T[XSTART]; j<endtime; j++, t += key->T[XSTEP])
RFsimu.cc:	for (i=0; i<key->length[0]; i++)
RFsimu.cc:	    for(w=0; w<key->timespacedim; w++)
RFsimu.cc:	      x[k] += aniso[n++] * key->x[w][i];
RFsimu.cc:      if (key->grid) {/* grid; with or without time component */
RFsimu.cc:	    for (n=d=0; d<key->timespacedim; d++, k+=3) {
RFsimu.cc:	      for(w=0; w<key->timespacedim; w++) 
RFsimu.cc:		x[k] += aniso[n++] * key->x[w][i]; 
RFsimu.cc:	  for (w=0; w<key->timespacedim; w++) {y[w]=key->x[w][XSTART]; yi[w]=0;}
RFsimu.cc:	      for(w=0; w<key->timespacedim; w++) {
RFsimu.cc:	    y[i] += key->x[i][XSTEP];
RFsimu.cc:	    while(yi[i]>=key->length[i]) {
RFsimu.cc:	      y[i] = key->x[i][XSTART];
RFsimu.cc:		y[i] += key->x[i][XSTEP];
RFsimu.cc:	for (k=i=0; i<key->totalpoints; i++)
RFsimu.cc:	    for(w=0; w<key->timespacedim; w++) x[k] += aniso[n++] * key->x[w][i];
RFsimu.cc:  } else { /* not key->anisotropy, no time component */   
RFsimu.cc:      //     printf("transform2 %d %d %d %d\n", key->anisotropy, key->grid,
RFsimu.cc://	     truetimespacedim, key->timespacedim);
RFsimu.cc:    assert(truetimespacedim == key->timespacedim);
RFsimu.cc:    if (key->grid) {
RFsimu.cc:      for (k=d=0; d<key->timespacedim; d++) {
RFsimu.cc:	  x[k++] = key->x[d][i] * aniso[0]; 
RFsimu.cc:      for (k=i=0; i<key->totalpoints; i++) {
RFsimu.cc:        for (j=0; j<key->timespacedim; j++) x[k++] = key->x[j][i] * aniso[0];
RFsimu.cc:  assert(key->meth[key->n_unimeth].S==NULL);
RFsimu.cc:  assert(key->meth[key->n_unimeth].destruct==NULL);
RFsimu.cc:    key->meth[key->n_unimeth].unimeth_alreadyInUse =
RFsimu.cc:      key->meth[*last_incompatible].unimeth_alreadyInUse;
RFsimu.cc:    key->meth[key->n_unimeth].unimeth=key->meth[*last_incompatible].unimeth;
RFsimu.cc:    key->meth[key->n_unimeth].S=key->meth[*last_incompatible].S; // necessary
RFsimu.cc:    key->meth[key->n_unimeth].destruct=key->meth[*last_incompatible].destruct;
RFsimu.cc:    key->meth[key->n_unimeth].incompatible = 
RFsimu.cc:	key->meth[*last_incompatible].incompatible;
RFsimu.cc:    key->meth[*last_incompatible].S = NULL;
RFsimu.cc:    key->meth[*last_incompatible].destruct = NULL;
RFsimu.cc:  } else idx=key->n_unimeth;
RFsimu.cc:  key->meth[idx].unimeth = m;
RFsimu.cc:  key->meth[idx].incompatible = incompatible;
RFsimu.cc:  key->meth[idx].unimeth_alreadyInUse = false;
RFsimu.cc:  key->n_unimeth++;
RFsimu.cc:  // note that key->n_unimeth had been decreased before this function
RFsimu.cc:  if (key->meth[*M].destruct != NULL) key->meth[*M].destruct(&(key->meth[*M].S));
RFsimu.cc:  assert(key->meth[*M].S==NULL);
RFsimu.cc:  key->meth[*M].destruct=NULL;
RFsimu.cc:  if (key->meth[*M].incompatible) {
RFsimu.cc:    key->meth[*M].unimeth = key->meth[*last_incompatible].unimeth;
RFsimu.cc:    key->meth[*M].unimeth_alreadyInUse =
RFsimu.cc:	key->meth[*last_incompatible].unimeth_alreadyInUse;
RFsimu.cc:    key->meth[*M].S = key->meth[*last_incompatible].S;
RFsimu.cc:    key->meth[*last_incompatible].S=NULL;
RFsimu.cc:    key->meth[*M].incompatible = key->meth[*last_incompatible].incompatible;
RFsimu.cc:    key->meth[*M].destruct=key->meth[*last_incompatible].destruct;
RFsimu.cc:    key->meth[*last_incompatible].destruct=NULL;
RFsimu.cc:  key->n_unimeth--;
RFsimu.cc:  if (idx==key->n_unimeth){ // deleting of the very last entry
RFsimu.cc:    assert(*M==key->n_unimeth || *last_incompatible + 1 == key->n_unimeth); 
RFsimu.cc:    assert(idx>=0 && idx<key->n_unimeth);
RFsimu.cc:    key->meth[idx].unimeth = key->meth[key->n_unimeth].unimeth;
RFsimu.cc:    key->meth[idx].unimeth_alreadyInUse = 
RFsimu.cc:	key->meth[key->n_unimeth].unimeth_alreadyInUse;
RFsimu.cc:    key->meth[idx].S = key->meth[key->n_unimeth].S;
RFsimu.cc:    key->meth[key->n_unimeth].S=NULL;
RFsimu.cc:    key->meth[idx].incompatible = key->meth[key->n_unimeth].incompatible;
RFsimu.cc:    key->meth[idx].destruct = key->meth[key->n_unimeth].destruct;
RFsimu.cc:    key->meth[key->n_unimeth].destruct=NULL;
RFsimu.cc:  key->meth[key->n_unimeth].unimeth_alreadyInUse = false;
RFsimu.cc:  SimulationType DirectFst = key->totalpoints <= best_dirct ? Direct : Forbidden;
RFsimu.cc:  SimulationType DirectLst = key->totalpoints <= max_dirct ? Direct : Forbidden;
RFsimu.cc:  if (!key->grid) Allowed[CircEmbed] = Allowed[CircEmbedCutoff] = 
RFsimu.cc:  for (v=0; v<key->ncov; v++) {
RFsimu.cc:    cov = &(CovList[key->cov[v].nr]);
RFsimu.cc:    key->IML[v] = -1;
RFsimu.cc:	key->cov[v].truetimespacedim <= 2;
RFsimu.cc:    if (key->cov[v].truetimespacedim == 3 && key->grid) {
RFsimu.cc:    if (v<key->ncov-1 && key->cov[v].op) {
RFsimu.cc:    cov->info(key->cov[v].param, &maxdim, &CEbadlybehaved);
RFsimu.cc://  printf("timespacedim %d %d %s\n", key->timespacedim, key->cov[v].truetimespacedim, cov->name);
RFsimu.cc:    assert(key->cov[v].truetimespacedim <= maxdim);
RFsimu.cc:    if (key->grid && CEbadlybehaved && DECISION_PARAM.exactness==DECISION_TRUE) {
RFsimu.cc:    if ((((key->ncov==1 || DECISION_PARAM.exactness==DECISION_FALSE) && 
RFsimu.cc:	  CEbadlybehaved) || CEbadlybehaved > 1) && key->grid) {
RFsimu.cc:      // key->ncov > 1 laesst hoffen, dass die andere Kovarianzfunktion
RFsimu.cc:      if (key->cov[v].truetimespacedim==2 || CEbadlybehaved > 1) {
RFsimu.cc:      if (key->cov[v].truetimespacedim==3 && CEbadlybehaved>1) raw[nr++] = TBM3;
RFsimu.cc:    if (key->grid && DECISION_PARAM.exactness==DECISION_FALSE && 
RFsimu.cc:	key->totalpoints * (1 << key->timespacedim) * 2*sizeof(double) > maxmem){
RFsimu.cc:	key->ML[v][nml++] = raw[i];
RFsimu.cc:    key->NML[v] = nml;
RFsimu.cc:  for (v=0; v<key->ncov; v++) if (CovList[key->cov[v].nr].cov==nugget){
RFsimu.cc:    if (!key->anisotropy) {
RFsimu.cc:      if (anyFirstCE) key->ML[v][nml++] = CircEmbed;
RFsimu.cc:      if (anyFirstDirect) key->ML[v][nml++] = Direct;
RFsimu.cc:    key->ML[v][nml++] = Nugget;
RFsimu.cc:    key->NML[v] = nml;
RFsimu.cc:    for (v=0; v<key->ncov; v++) {
RFsimu.cc:      PRINTF("%s: ", CovList[key->cov[v].nr].name);
RFsimu.cc:      for (i=0; i < key->NML[v]; i++) PRINTF("%s, ", METHODNAMES[key->ML[v][i]]);
RFsimu.cc:  for (v=0; v<key->ncov; v++) {
RFsimu.cc:    if (key->cov[v].left) {
RFsimu.cc:      if (v>0 && key->cov[v-1].op) key->cov[v].method = key->cov[v-1].method;
RFsimu.cc:	(key->IML[v])++;
RFsimu.cc://	       v, key->IML[v], key->NML[v], key->ML[v][key->IML[v]]); 
RFsimu.cc:	if (key->IML[v] >= key->NML[v]) return v + 1;
RFsimu.cc:	key->cov[v].method = key->ML[v][key->IML[v]];
RFsimu.cc:  key->storing = storing;
RFsimu.cc:  key->covFct = covFct;
RFsimu.cc:  timespacedim = spatialdim + (int) Time; // may not set to key->timespacedim,
RFsimu.cc:  //                      since key->timespacedim possibly by DeleteKeyNotTrend
RFsimu.cc:				key->cov, &(key->active))) != NOERROR)
RFsimu.cc:      kc = &(key->cov[v]);
RFsimu.cc:      key->active &= kc->method == meth;
RFsimu.cc:      key->cov[v].method = meth;
RFsimu.cc:       kc = &(key->cov[i]);
RFsimu.cc:  if (key->active) {   
RFsimu.cc:     assert(key->x[0]!=NULL);
RFsimu.cc:     key->active = 
RFsimu.cc:	 (covFct = key->covFct) &&
RFsimu.cc:	 (key->grid == grid) && 
RFsimu.cc:	 ((key->grid && lx==3) || (!key->grid && key->totalpoints==lx)) &&
RFsimu.cc:	 (key->spatialdim==spatialdim) && 
RFsimu.cc:	 (key->distribution==distr) &&
RFsimu.cc:	 (key->ncov==ncov) &&
RFsimu.cc:	 (key->anisotropy==anisotropy) &&
RFsimu.cc:	 (Time == key->Time && 
RFsimu.cc:	  (!Time || !memcmp(key->T, T, sizeof(double) * 3))) &&
RFsimu.cc:	 (!memcmp(key->x[0], x, totalBytes));
RFsimu.cc://     if (GENERAL_PRINTLEVEL>5 && !key->active) {
RFsimu.cc://       PRINTF("failure with previous initialisation at spatialdim=%d grid=%d distrib=%d ncov=%d  aniso=%d time=%d key->T=%d op=%d x=%d\n",
RFsimu.cc://	      key->spatialdim==spatialdim, key->grid == grid,
RFsimu.cc://	      key->distribution==distr, key->ncov==ncov, 
RFsimu.cc://	      key->anisotropy==anisotropy,
RFsimu.cc://	      Time == key->Time, 
RFsimu.cc://	      !(Time) || ! memcmp(key->T, T, sizeof(double) * 3),
RFsimu.cc://	      !memcmp(key->x[0], x, totalBytes));
RFsimu.cc:  if (key->active) {// detected that all relevant parameters agree, 
RFsimu.cc:    for (d = key->timespacedim; d<MAXDIM; d++) {assert(key->x[d]==NULL);} 
RFsimu.cc:  } else {// ! key->active
RFsimu.cc:    key->timespacedim = timespacedim;
RFsimu.cc:    key->spatialdim = spatialdim;
RFsimu.cc:    key->grid= grid;
RFsimu.cc:    key->anisotropy = anisotropy;    
RFsimu.cc:    key->distribution=distr; 
RFsimu.cc:    key->ncov=ncov;
RFsimu.cc:    if (key->x[0]!=NULL) free(key->x[0]);
RFsimu.cc:    if ((key->x[0]=(double*) malloc(totalBytes))==NULL){
RFsimu.cc:    memcpy(key->x[0], x, totalBytes);
RFsimu.cc:    for (d=1; d<key->spatialdim; d++) key->x[d]= &(key->x[0][d * lx]);
RFsimu.cc:    for (; d<MAXDIM; d++)  key->x[d]=NULL;
RFsimu.cc:    if (key->Time = Time) {
RFsimu.cc:      if (!key->anisotropy) { error = ERRORTIMENOTANISO; goto ErrorHandling; }
RFsimu.cc:      memcpy(key->T, T, sizeof(double) * 3);
RFsimu.cc:      if (key->grid) {
RFsimu.cc:	key->x[key->spatialdim] = key->T;
RFsimu.cc:   key->totalparam = anisotropy 
RFsimu.cc://    if (key->meth[v].destruct!=NULL) {
RFsimu.cc://      key->meth[v].destruct(&(key->meth[v].S));
RFsimu.cc://      key->meth[v].destruct = NULL;
RFsimu.cc:  if (key->grid) { 
RFsimu.cc:	(InternalGetGridSize(key->x,&key->timespacedim,key->length))) {
RFsimu.cc:    for (key->spatialtotalpoints=1, d=0; d<key->spatialdim; d++) {
RFsimu.cc:      key->spatialtotalpoints *= key->length[d];
RFsimu.cc:    key->totalpoints = key->spatialtotalpoints;
RFsimu.cc:    if (key->Time) key->totalpoints *= key->length[key->spatialdim];
RFsimu.cc:    key->totalpoints = key->spatialtotalpoints = key->length[0]= lx;
RFsimu.cc:    if (key->Time) {
RFsimu.cc:      Tx[0] = key->T;
RFsimu.cc:      if (InternalGetGridSize(Tx,&Tdim,&(key->length[key->spatialdim]))) {
RFsimu.cc:      key->totalpoints *= key->length[key->spatialdim];
RFsimu.cc:    for (d=1; d<key->spatialdim; d++) key->length[d]=0; 
RFsimu.cc:  for (d=key->timespacedim; d<MAXDIM; d++) key->length[d] = (int) RF_NAN; // 1
RFsimu.cc:      key->ncov==1 ||
RFsimu.cc:      (key->ncov==2 && !key->anisotropy && (key->cov[0].method==Nugget ||
RFsimu.cc:					    key->cov[1].method==Nugget));
RFsimu.cc:  for (v=key->ncov-2; v>=0; v--)  // above one_model_only only for making
RFsimu.cc:  key->n_unimeth = 0;
RFsimu.cc:  for (v=0; v<key->ncov; v++) key->cov[v].left=true;
RFsimu.cc:    for (v=0; v<key->ncov; v++) {
RFsimu.cc:      kc = &(key->cov[v]);
RFsimu.cc:	  if (nc <= 0 || nc + v >= key->ncov) {
RFsimu.cc:	      if (kc->method != key->cov[i].method) {
RFsimu.cc:      if (v>0 && op[v-1] && kc->method!=key->cov[v-1].method) {
RFsimu.cc:      key->NML[v] = 1;
RFsimu.cc:      key->IML[v] = -1;
RFsimu.cc:      key->ML[v][0] = kc->method; 
RFsimu.cc:    for (v=0; v<key->ncov; v++) {
RFsimu.cc:	if (CovList[key->cov[v].nr].type == ISOHYPERMODEL ||
RFsimu.cc:	    CovList[key->cov[v].nr].type == ANISOHYPERMODEL) {
RFsimu.cc://    printf("XXX %d %d %d %d ledt: %d %d\n", key->NML[0], key->NML[1], 
RFsimu.cc://	   key->cov[0].method, key->cov[1].method,
RFsimu.cc://	   key->cov[0].left, key->cov[1].left);
RFsimu.cc://   printf("keynunimeth %d\n", key->n_unimeth);
RFsimu.cc:	       error_covnr, CovList[key->cov[error_covnr - 1].nr].name);
RFsimu.cc:    for (v=0; v<key->ncov; v++)
RFsimu.cc:      method_used[key->cov[v].method] += key->cov[v].left; 
RFsimu.cc:	//                increments key->n_unimeth
RFsimu.cc://	printf("keynunimeth %d\n", key->n_unimeth);
RFsimu.cc:	  while(key->cov[v].method!=m || !key->cov[v].left) v++;
RFsimu.cc:	  key->ML[v][key->IML[v]] = Nothing; 
RFsimu.cc://     printf("front m loop keynunimeth %d\n", key->n_unimeth);
RFsimu.cc:    for (M=0; M<key->n_unimeth; M++) {
RFsimu.cc:	// printf("M=%d\n", M, key->n_unimeth);
RFsimu.cc:      if (!key->meth[M].unimeth_alreadyInUse) {
RFsimu.cc://        printf("M NML %d %d %d %d\n", M, key->n_unimeth, key->NML[0], key->NML[1]);
RFsimu.cc:	meth =  &key->meth[M];
RFsimu.cc:	for (v=0; v<key->ncov; v++) left[v] = key->cov[v].left; // sicherung,
RFsimu.cc:	// die methode funktioniert -- ueber key->method ist es zu schwierig
RFsimu.cc:		 errorloc_save, M, METHODNAMES[meth->unimeth], key->n_unimeth);
RFsimu.cc:	    for (v=0; v<key->ncov; v++)
RFsimu.cc:		     v, CovList[key->cov[v].nr].name,
RFsimu.cc:		     key->cov[v].left ? "true" : "false", 
RFsimu.cc:		     METHODNAMES[key->cov[v].method]);
RFsimu.cc://      printf("A NML %d %d %d %d\n", M, M<key->n_unimeth, key->NML[0], key->NML[1]);
RFsimu.cc:	      for (v=0; v<key->ncov; v++) {
RFsimu.cc:		kc = &(key->cov[v]);
RFsimu.cc://      printf("M, nunimeth %d %d\n", M, key->n_unimeth);
RFsimu.cc://    for (v=0; v<key->ncov; v++)
RFsimu.cc://	printf("left: %d %d %d\n", v, key->cov[v].left, key->ncov); 
RFsimu.cc:      for (v=0; v<key->ncov; v++) {
RFsimu.cc:	  if (key->cov[v].left) {
RFsimu.cc:  //    for (v=0; v<key->ncov; v++) 
RFsimu.cc://		v, METHODNAMES[key->cov[v].method], 
RFsimu.cc://		 METHODNAMES[key->ML[v][0]], key->NML[v]);
RFsimu.cc:    for (v=0; v<key->ncov; v++) if (key->cov[v].left) {
RFsimu.cc:      key->cov[v].method = Nothing;
RFsimu.cc:    for (v=0; v<key->ncov; v+=vplus) {
RFsimu.cc:      kc = &(key->cov[v]);
RFsimu.cc:        if (key->NML[v]==0) {
RFsimu.cc:	for (i=0; i<key->NML[v]; i++) {
RFsimu.cc:	  if (key->ML[v][i] == Nothing) {
RFsimu.cc:		       METHODNAMES[i], i, key->NML[v]);
RFsimu.cc:		     METHODNAMES[key->ML[v][i]], i, key->NML[v]); 
RFsimu.cc:	  for (w=0; w<key->ncov; w++) left[w] = key->cov[w].left; // sicherung,
RFsimu.cc:	  while (v + vplus < key->ncov && kcdummy->op) {
RFsimu.cc:	    kcdummy->method = key->ML[v][i];
RFsimu.cc:	    kcdummy = &(key->cov[v + vplus]);
RFsimu.cc:	  kcdummy->method = key->ML[v][i];
RFsimu.cc:	  error = init_method[key->meth[M].unimeth](key, M);
RFsimu.cc:	    for (w=0; w<key->ncov; w++) {
RFsimu.cc:	      kcdummy = &(key->cov[w]);
RFsimu.cc:	  if (key->ncov>2 && GENERAL_PRINTLEVEL>0) 
RFsimu.cc:    } // for v < key->ncov
RFsimu.cc:  if (!(key->active = error==NOERROR)) goto ErrorHandling;
RFsimu.cc:  key->compatible = last_incompatible <= 0; // if at most one incompatible
RFsimu.cc:  key->active = false;
RFsimu.cc:  if (!key->active) {*error=ERRORNOTINITIALIZED; goto ErrorHandling;}
RFsimu.cc://  printf("addtrend %f \n", key->mean);
RFsimu.cc:  switch (key->TrendModus) {
RFsimu.cc:	if (key->mean!=0.0) {
RFsimu.cc:	  long int endfor= *n * key->totalpoints;
RFsimu.cc:	  for(i=0; i<endfor; i++) res[i] += key->mean;
RFsimu.cc:  if (!key->active || (!key->storing && internal_n>1)) {
RFsimu.cc:    long endfor=key->totalpoints * *n / 2;
RFsimu.cc:  if (!(key->active = GENERAL_STORING && key->storing))
RFsimu.cc:    key->active = false;
RFsimu.cc:  if (!key->compatible) {
RFsimu.cc:      if ((part_result=(double *) malloc(sizeof(double) * key->totalpoints))
RFsimu.cc:  for (ni=0; ni<nn; ni++, res += key->totalpoints) {
RFsimu.cc:    if (key->n_unimeth == 0 || !key->meth[0].incompatible)
RFsimu.cc:      for (i=0; i<key->totalpoints; i++) {
RFsimu.cc:    for(m=0; m<key->n_unimeth; m++) {
RFsimu.cc:      if (!key->active) {error=ERRORNOTINITIALIZED; goto ErrorHandling;}
RFsimu.cc:      meth = &(key->meth[m]);
RFsimu.cc:	  if (GENERAL_PRINTLEVEL>=7) PRINTF("extra %d\n", key->compatible);
RFsimu.cc:	  for (i=0; i<key->totalpoints; i++) res[i] += part_result[i];
RFsimu.cc:  key->active = false;
RFsimu.cc:      return GetModelInfo(key->cov, key->ncov, key->totalparam,
RFsimu.cc:			  key->totalpoints);
RFspectral.cc:  meth = &(key->meth[m]);
RFspectral.cc://  if (key->Time) {Xerror=ERRORTIMENOTALLOWED; goto ErrorHandling;}
RFspectral.cc:  // noerror_repeat = key->anisotropy;
RFspectral.cc:  for (v=0; v<key->ncov; v++) {
RFspectral.cc:    keycov = &(key->cov[v]);
RFspectral.cc:        if (key->cov[v-1].op) {
RFspectral.cc:          if (key->cov[v-1].method != SpectralTBM){
RFspectral.cc:		     v, key->cov[v-1].op, key->ncov, key->cov[v-1].method,
RFspectral.cc:		     METHODNAMES[key->cov[v-1].method],
RFspectral.cc:	// noerror_repeat= true; // only for !key->anisotropy ??
RFspectral.cc:  meth = &(key->meth[m]);
RFspectral.cc:  assert(key->active);
RFspectral.cc:    kc = &(key->cov[meth->covlist[v]]);
RFspectral.cc:  kc = &(key->cov[meth->covlist[0]]);
RFspectral.cc:  for (k=0; k<key->totalpoints; k++) { res[k]=0.0; }
RFspectral.cc:    kc = &(key->cov[meth->covlist[v]]);
RFspectral.cc:      if (key->timespacedim==1) {
RFspectral.cc:	for (nx=0; nx<key->length[0]; nx++) {
RFspectral.cc:      } else { // key->timespacedim==2
RFspectral.cc:	for (ny=0; ny<key->length[1]; ny++) {	
RFspectral.cc:	  for (nx=0; nx<key->length[0]; nx++) {
RFspectral.cc:	for (nx=0; nx<key->totalpoints; nx++) {	
RFspectral.cc:	for (nx=0; nx<key->totalpoints; nx++) {	
RFspectral.cc:  for (nx=0; nx<key->totalpoints; nx++) { res[nx] = res[nx]*sqrttwodivbyn; }  
RFtbm.cc:  meth = &(key->meth[m]);
RFtbm.cc://  assert(key->cov[0].aniso[0] != 0.0);
RFtbm.cc://  printf("tbm ansio %f\n", key->cov[0].aniso[0] );
RFtbm.cc:  assert(key->covFct == CovFct);
RFtbm.cc:  for (v=0; v<key->ncov; v++) {
RFtbm.cc:    kc = &(key->cov[v]);
RFtbm.cc:      if (key->anisotropy) {
RFtbm.cc:	  lastmatching = key->totalparam - 1;     
RFtbm.cc:      if (key->Time) {
RFtbm.cc:        firsttimecomponent = key->totalparam - key->timespacedim;
RFtbm.cc:	while (!ce_dim2 && kc->op && (++v)<key->ncov) {
RFtbm.cc:	  kc = &(key->cov[v]);
RFtbm.cc:		   (int) (key->Time && first->param[lasttimecomponent]==0.0) - 1;
RFtbm.cc:    if (key->grid) {
RFtbm.cc:        if ((key->x[d][XSTEP]<mindelta) && (key->x[d][XSTEP]>0)) 
RFtbm.cc:          {mindelta=key->x[d][XSTEP];}
RFtbm.cc:      if (key->totalpoints > 50000) {
RFtbm.cc:      for (ix=i=0; i<key->totalpoints; i++, ix+=key->timespacedim) {
RFtbm.cc:	 for (jx=j=0; j<i; j++, jx+=key->timespacedim) {
RFtbm.cc:	    for (dist=0.0, d=0; d<key->timespacedim; d++) {
RFtbm.cc:	      diff = key->x[d][ix] - key->x[d][jx]; 
RFtbm.cc:    if (key->anisotropy)
RFtbm.cc:    GetTrueDim(key->anisotropy, key->timespacedim, simuparam,
RFtbm.cc://  printf("TRANSF %d %d %d %d  %d %d\n", iloop, key->anisotropy, key->Time,
RFtbm.cc://	   key->grid, totaltimespacedim, s->simugrid);
RFtbm.cc:      for (g=1; g<key->timespacedim; g++) 
RFtbm.cc:	for (g=0; g<key->timespacedim; g++) {
RFtbm.cc://        key->grid, s->simugrid);
RFtbm.cc:  for (v=0; v<key->ncov; v++) {
RFtbm.cc:    kc = &(key->cov[v]);
RFtbm.cc:      if (v<key->ncov-1 && kc->op) {
RFtbm.cc:	if (key->cov[v+1].method!=method) {
RFtbm.cc:      if ((!key->anisotropy && cov->type!=FULLISOTROPIC) ||
RFtbm.cc:	  while (actcov>0 && key->cov[meth->covlist[actcov-1]].op) {
RFtbm.cc:	      key->cov[meth->covlist[actcov-1]].left = true;
RFtbm.cc:	  while (v<key->ncov && key->cov[v].op) v++;  
RFtbm.cc:	while (actcov>0 && key->cov[meth->covlist[actcov-1]].op) {
RFtbm.cc:	  key->cov[meth->covlist[actcov-1]].left = true;
RFtbm.cc:	while (v<key->ncov && key->cov[v].op) v++;  
RFtbm.cc:      ParamList[Aniso] = ((key->anisotropy) ? quot : 1.0 / quot) / linesimuscale;
RFtbm.cc:     Xerror = internal_InitSimulateRF(xline, key->T, 1, 3, true, 
RFtbm.cc:  if (key->anisotropy) return NOERROR_REPEAT;
RFtbm.cc:  key->active = false;
RFtbm.cc:  assert(key->active);
RFtbm.cc:  meth = &(key->meth[m]);
RFtbm.cc:    totpoints = key->totalpoints;
RFtbm.cc:    totpoints = key->spatialtotalpoints;
RFtbm.cc:	  gridlenz=key->length[2];
RFtbm.cc:	  gridleny=key->length[1];
RFtbm.cc:	  gridlenx=key->length[0];
RFtbm.cc:  for (n=0; n<key->totalpoints; n++) res[n]=0.0; 
RFtbm.cc:	unitvector3D(key->spatialdim, &deltax, &deltay, &deltaz);
RFtbm.cc:  for(i=0;i<key->totalpoints;i++) 
