extremes.cc:	  if (kc->simugrid) {
extremes.cc:	      if (kc->genuine_dim[d]) {
extremes.cc:	        if ((next = ((min[d] > kc->x[XENDD[d]]) ||
extremes.cc:			     (max[d] < kc->x[XSTARTD[d]])))) { break;}
extremes.cc:		if (min[d] < kc->x[XSTARTD[d]]) {start[d]=0;}
extremes.cc:		else start[d] = (int) ((min[d] - kc->x[XSTARTD[d]]) / 
extremes.cc:				       kc->x[XSTEPD[d]]);
extremes.cc:		end[d] = (int) ((max[d] - kc->x[XSTARTD[d]]) / 
extremes.cc:				kc->x[XSTEPD[d]]);
extremes.cc:	      coord[kc->idx[d]] = startcoord[d] = 
extremes.cc:		  kc->x[XSTARTD[d]] +(double)start[d] * kc->x[XSTEPD[d]];
extremes.cc:	      coord[kc->idx[d]] += kc->x[XSTEPD[d]];
extremes.cc:		coord[kc->idx[d]] = startcoord[d];
extremes.cc:		coord[kc->idx[d]] += kc->x[XSTEPD[d]];
extremes.cc:	      for (d=0; d<dim; d++) y[d] = kc->x[j++];
Hyperfcts.cc:  // printf("get: %s %d %f\n", CovList[kc->nr].name, instance, kc->param[KAPPA]);
Hyperfcts.cc:  if (kc->nr == EXPONENTIAL) {
Hyperfcts.cc:  } else if (kc->nr == CAUCHY) {
Hyperfcts.cc:    if (kc->nr == GENERALISEDCAUCHY || kc->nr==STABLE) {
Hyperfcts.cc:    } else if (kc->nr == WHITTLEMATERN) {
Hyperfcts.cc:    if (kc->param[KAPPA] <= thres[0]) {
Hyperfcts.cc:    } else if (kc->param[KAPPA] <= thres[1]) {
Hyperfcts.cc:  param = kc->param;  
Hyperfcts.cc:  nsub= (int) (kc->param[HYPERNR]);
Hyperfcts.cc:      store[v] = kc->aniso[0];
Hyperfcts.cc:      kc->aniso[0] = d;
Hyperfcts.cc:  if ((kc->nr == GENERALISEDCAUCHY && kc->param[KAPPA] <= 1.0) ||
Hyperfcts.cc:      (kc->nr == STABLE && kc->param[KAPPA] <= 1.0) || 
Hyperfcts.cc:      (kc->nr == EXPONENTIAL) || 
Hyperfcts.cc:      (kc->nr == WHITTLEMATERN && kc->param[KAPPA] <= 0.5)) {
Hyperfcts.cc:  } else if (kc->nr == BROWNIAN) {
Hyperfcts.cc:      q[INTRINSIC_RAWR] = (kc->truetimespacedim <= 2 
Hyperfcts.cc:			    ? ((kc->param[KAPPA] <= 1.5) ? 1.0 : 2.0)
Hyperfcts.cc:			    : ((kc->param[KAPPA] <= 1.0) ? 1.0 : 2.0));
Hyperfcts.cc:  kc->param[INTRINSIC_RAWR] *= 2.0;
Hyperfcts.cc:  param = kc->param;  
Hyperfcts.cc:  nsub= (int) (kc->param[HYPERNR]);
Hyperfcts.cc:    store[v] = kc->aniso[0];
Hyperfcts.cc:    kc->aniso[0] = d;
Hyperfcts.cc:    if (v<nsub && CovList[kc->nr].variogram &&  kc->op)
Hyperfcts.cc:  param = kc->param;  
Hyperfcts.cc:  if (kc->genuine_last_dimension) 
Hyperfcts.cc:  nsub= (int) (kc->param[HYPERNR]);  
Hyperfcts.cc:  endfor = ANISO +  kc->dim * kc->dim - 1;
Hyperfcts.cc:      if (kc->param[i]!=0.0) {
Hyperfcts.cc:		  kc->param[i],  1 - (ANISO - i), v); // i - ANISO + 1 gibt
MPP.cc:    if ((kc->method==AdditiveMpp) && kc->left
MPP.cc:        && (kc->param[VARIANCE]>0)) {
MPP.cc:      assert(kc->nr>=0 && kc->nr<currentNrCov);
MPP.cc:      cov = &(CovList[kc->nr]);
MPP.cc:      if (key->Time && !kc->genuine_last_dimension && 
MPP.cc:      if ((error=cov->check(kc->param, kc->truetimespacedim, 
MPP.cc:      if ((v<key->ncov-1 &&  kc->op)) {
MPP.cc:      kc->left=false;
MPP.cc:    timespacedim = kc->truetimespacedim;
MPP.cc:  if (kc->simugrid) {
MPP.cc:      s->min[kc->idx[d]]   = kc->x[XSTARTD[d]];
MPP.cc:      s->length[kc->idx[d]]= kc->x[XSTEPD[d]] * (double) (key->length[d] - 1);
MPP.cc:	if (kc->x[ix+d] < s->min[d]) s->min[d] = kc->x[ix+d];
MPP.cc:	if (kc->x[ix+d] > max[d]) max[d] = kc->x[ix+d];
MPP.cc:  CovList[kc->nr].add_mpp_scl(s, timespacedim, kc->param);
MPP.cc:  s->MppFct = CovList[kc->nr].add_mpp_rnd;
MPP.cc:    factor = sqrt(kc->param[VARIANCE] / 
MPP.cc:    lambda = kc->param[VARIANCE] * s->effectivearea; 
MPP.cc:  timespacedim = kc->simugrid ? key->timespacedim : kc->truetimespacedim;
MPP.cc:    if (kc->simugrid) {
MPP.cc:	if (kc->genuinedim[d]) {
MPP.cc:          if (min[d]< kc->x[XSTARTD[d]]) {start[d]=0;}
MPP.cc:	  else start[d] = (int) ((min[d] - kc->x[XSTARTD[d]]) / 
MPP.cc:				 kc->x[XSTEPD[d]]);
MPP.cc:	  end[d] = 1 + (int) ((max[d] - kc->x[XSTARTD[d]]) /
MPP.cc:			      kc->x[XSTEPD[d]]);
MPP.cc:	coord[kc->idx[d]] = startcoord[d] = 
MPP.cc:	    kc->x[XSTARTD[d]] + (double) start[d] * kc->x[XSTEPD[d]];
MPP.cc:	coord[kc->idx[d]] += kc->x[XSTEPD[d]];
MPP.cc:	  coord[kc->idx[d]] = startcoord[d];
MPP.cc:	  coord[kc->idx[d]] += kc->x[XSTEPD[d]];
MPP.cc:	for (d=0; d<timespacedim; d++, j++) y[d] = kc->x[j];
RFcircembed.cc:    dim = kc->truetimespacedim;
RFcircembed.cc:    GetCornersOfGrid(key, dim, kc->aniso, sx);
RFcircembed.cc:      dummy = key->x[d][XSTEP] * (double) (key->length[d] - 1) * kc->aniso[0];
RFcircembed.cc://    printf("** %d\n", kc->nr);
RFcircembed.cc:    memcpy(&(sc->param[ANISO]), &(kc->param[ANISO]), sizeof(double) * n_aniso);
RFcircembed.cc:      err =  GetOrthogonalUnitExtensions(kc->aniso, key->timespacedim, grid_ext);
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i],subi++, mkString(METHODNAMES[kc->method]));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, ScalarInteger(kc->dim));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, ScalarInteger(kc->truetimespacedim));
RFgetNset.cc:		   Int(kc->length, kc->simugrid ? kc->dim : 0, MAX_INT));
RFgetNset.cc:		   Int(kc->idx, kc->simugrid ? kc->dim :0, MAX_INT));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, mkString(CovList[kc->nr].name));
RFgetNset.cc:	SET_VECTOR_ELT(submodel[i], subi++, mkString(OP_SIGN[kc->op]));
RFgetNset.cc:		   Logi(kc->genuine_dim, kc->simugrid ? kc->dim : 0, MAX_INT));
RFgetNset.cc:		   ScalarLogical(kc->genuine_last_dimension));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, ScalarLogical(kc->simugrid));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, ScalarLogical(!kc->left));
RFgetNset.cc:		   : Num(kc->param, totalparam, MAX_INT));
RFgetNset.cc:    SET_VECTOR_ELT(submodel[i], subi++, (kc->dim<=0) ? allocVector(VECSXP, 0)
RFgetNset.cc:		   : Mat(kc->aniso, kc->dim, // kc->truetimespacedim
RFgetNset.cc:			 kc->dim, MAX_INT)
RFgetNset.cc:    if (kc->x == NULL) 
RFgetNset.cc:		       Mat(kc->x, kc->simugrid ? 3 : totalpoints, 
RFgetNset.cc:			   kc->truetimespacedim, MAX_INT));
RFhyperplan.cc:      optdim=2; // falls dies gelockert wird, so kc->idx[d] nicht vergessen!
RFhyperplan.cc:    if (kc->method==Hyperplane && kc->left) {
RFhyperplan.cc:      cov = &(CovList[kc->nr]);
RFhyperplan.cc:      assert(kc->nr>=0 && kc->nr<currentNrCov);
RFhyperplan.cc:      assert(kc->param[VARIANCE] >= 0.0);
RFhyperplan.cc:      if ((key->ncov>v+1 && kc->op) || 
RFhyperplan.cc:      timespacedim = kc->truetimespacedim;
RFhyperplan.cc:	  v += (int) kc->param[HYPERNR];
RFhyperplan.cc:      if ((error = cov->check(kc->param, timespacedim, Hyperplane)) 
RFhyperplan.cc:     kc->left = false;
RFhyperplan.cc:  timespacedim = kc->truetimespacedim;
RFhyperplan.cc:  GetCenterAndDiameter(key, kc->simugrid, timespacedim, kc->truetimespacedim,
RFhyperplan.cc:		       kc->x, kc->aniso, s->center, s->rx, &(s->radius));
RFhyperplan.cc:  for (d=0; d<kc->truetimespacedim; d++) s->rx[d] *= 0.5;
RFhyperplan.cc:  timespacedim = kc->truetimespacedim;
RFhyperplan.cc:	deltax = kc->x[XSTEPD[0]];
RFhyperplan.cc:	deltay = kc->x[XSTEPD[1]];
RFhyperplan.cc:	  if (kc->simugrid) {
RFhyperplan.cc:	    for (gy=kc->x[XSTARTD[1]], resindex=j=0; j<key->length[1]; j++) {
RFhyperplan.cc:	      for (gx= kc->x[XSTARTD[0]], i=0; i<key->length[0]; i++,
RFhyperplan.cc:	      if ((cell=determine_cell(kc->x[j], kc->x[j+1], hx, hy, hr,
RFnugget.cc://    printf("nugget %d %d %d %s \n", v, kc->nr, key->ncov, CovList[kc->nr].name);
RFnugget.cc:    assert((kc->nr >= 0) && (kc->nr < currentNrCov));
RFnugget.cc:    assert(kc->param[VARIANCE] >= 0.0);
RFnugget.cc:    cov = &(CovList[kc->nr]);
RFnugget.cc:    if ((kc->method==Nugget) && (kc->left)) {
RFnugget.cc:	  quotient = kc->param[nonzero_pos]/first->param[nonzero_pos];
RFnugget.cc:	    equal &= fabs(first->param[w] * quotient - kc->param[w]) <
RFnugget.cc:              (fabs(kc->param[w]) + 1.0*(kc->param[w]==0.0))
RFnugget.cc:      kc->left = false;
RFnugget.cc:  s->simple = key->timespacedim == kc->truetimespacedim;
RFnugget.cc:  s->simugrid = kc->simugrid;
RFnugget.cc:    if (kc->simugrid) {
RFnugget.cc:	s->diag[d] = kc->param[ANISO + i];
RFnugget.cc:      ordering(kc->x, key->totalpoints, kc->truetimespacedim, pos);
RFnugget.cc:	if (equal(oldpos, pos[i], kc->x, kc->truetimespacedim)) 
RFsimu.cc:    cov = &(CovList[kc->nr]); 
RFsimu.cc:    // printf("%d %d %d %d\n", v, kc->method, Method, (int) kc->left);
RFsimu.cc:    if (kc->method==Method && kc->left) {
RFsimu.cc:      assert((kc->nr >= 0) && (kc->nr < currentNrCov));
RFsimu.cc:      assert(kc->param[VARIANCE] >= 0.0);
RFsimu.cc:	error = cov->check(kc->param, kc->truetimespacedim, Method);
RFsimu.cc:	  (int) kc->param[HYPERNR] : 0;
RFsimu.cc:	kc->left = false;
RFsimu.cc:      kc->left = false;
RFsimu.cc:  if (kc->simugrid) {
RFsimu.cc:      kc->length[d] = kc->genuine_dim[d] ? key->length[d] : 1;
RFsimu.cc://	     kc->length[d], kc->genuine_dim[d], key->length[d]);
RFsimu.cc:  return Transform2NoGrid(key, kc->aniso, kc->truetimespacedim,
RFsimu.cc:			  kc->simugrid, &(kc->x));
RFsimu.cc:      cov = &(CovList[kc->nr]);
RFsimu.cc:      z = fabs(x[0] * kc->aniso[0]);
RFsimu.cc:      fct[w1] = kc->param[VARIANCE] * cov->cov(&z, kc->param, dim); 
RFsimu.cc:      abl[w1] = kc->param[VARIANCE] * cov->derivative(&z, kc->param)
RFsimu.cc:	* kc->aniso[0];
RFsimu.cc:      snd[w1] = kc->param[VARIANCE] * cov->secondderivt(&z, kc->param)
RFsimu.cc:	  * kc->aniso[0] * kc->aniso[0];
RFsimu.cc://	     cov->secondderivt(&z, kc->param),  cov->name, cov->secondderivt);
RFsimu.cc:      cov = &(CovList[kc->nr]);
RFsimu.cc:      z = fabs(x[0] * kc->aniso[0]);
RFsimu.cc:      fct[w] = kc->param[VARIANCE] * cov->cov(&z, kc->param, dim); 
RFsimu.cc:      abl[w] = kc->param[VARIANCE] * cov->derivative(&z, kc->param)
RFsimu.cc:	  * kc->aniso[0];
RFsimu.cc:        cov = &(CovList[kc->nr]);
RFsimu.cc:	var *= kc->param[VARIANCE];
RFsimu.cc:	for (k=0; k<kc->truetimespacedim; k++) z[k]=0.0;
RFsimu.cc:	for (ani=0, k=0; k<kc->truetimespacedim; k++) {
RFsimu.cc:	    z[k] += kc->aniso[ani++] * x[j];
RFsimu.cc:	    zw *= cov->cov(z, kc->param, kc->truetimespacedim);
RFsimu.cc:	    endfor = kc->truetimespacedim - 1;
RFsimu.cc:	    nsub = (int) kc->param[HYPERNR]; 
RFsimu.cc:	    zw *= cov->cov(z, kc->param, subdim);
RFsimu.cc://		   z[0], z[1], z[2], kc->param[VARIANCE], 
RFsimu.cc://		   kc->param[KAPPA1], kc->param[KAPPA2], kc->param[KAPPA3],
RFsimu.cc://		   subdim, cov->name, cov->cov(z, kc->param, subdim), zw);
RFsimu.cc:	    zw *= cov->cov(z, kc->param, 1 + (int)(cov_type==SPACEISOTROPIC));
RFsimu.cc:	if ((v<ncovM1) && (kc->op==0)) break;
RFsimu.cc:	//printf("covfct %d %d\n", v, kc->nr);
RFsimu.cc:        cov = &(CovList[kc->nr]); /* cov needed in FORMULA for Vario */
RFsimu.cc:	   nsub = (int) kc->param[HYPERNR];
RFsimu.cc:           z[0] = d * kc->aniso[0];
RFsimu.cc://				     d, kc->aniso[0]);
RFsimu.cc:	   zw *= cov->cov(z, kc->param, subdim);
RFsimu.cc:          zz = d * kc->aniso[0];
RFsimu.cc:	  var *= kc->param[VARIANCE];
RFsimu.cc:	  zw *= cov->cov(&zz, kc->param, 1);
RFsimu.cc:	if ((v<ncovM1) && (kc->op==0)) break;
RFsimu.cc://	       kc->param[KAPPA], v, covlist[v], kc->nr);
RFsimu.cc://	   *x, z[0], z[1], result, d, kc->aniso[0],
RFsimu.cc:    cov = &(CovList[kc->nr]);
RFsimu.cc:    *equal &= !memcmp(kc->param, ParamList, sizeof(double) * kappasP1);
RFsimu.cc:    memcpy(kc->param, ParamList, sizeof(double)* kappasP1);
RFsimu.cc:    if (kc->param[VARIANCE]<0.0) return ERRORNEGATIVEVAR;
RFsimu.cc:      *equal &= kc->op == op[v];
RFsimu.cc:      kc->op = op[v];
RFsimu.cc://	      kc->op, false xor false, false xor true, true xor true);
RFsimu.cc:	  xor (kc->op == 2))
RFsimu.cc:    GetNaturalScaling(&(kc->nr), &(kc->param[KAPPA]),
RFsimu.cc:    *equal &= !memcmp(&(kc->param[ANISO]), &(param[ANISO]), 
RFsimu.cc:    memcpy(&(kc->param[ANISO]), &(param[ANISO]), sizeof(double) * pAniso);
RFsimu.cc:    GetTrueDim(anisotropy, timespacedim, kc->param, cov->type, 
RFsimu.cc:	       &(kc->genuine_last_dimension), 
RFsimu.cc:	       &(kc->truetimespacedim), kc->aniso);
RFsimu.cc:    kc->dim = timespacedim;
RFsimu.cc:    if (cov->type==SPACEISOTROPIC && !kc->genuine_last_dimension)
RFsimu.cc:    if (kc->truetimespacedim==0) return ERRORTRIVIAL;
RFsimu.cc:    error = check_within_range(kc->param, cov, kc->truetimespacedim, NULL);
RFsimu.cc:    cov->info(kc->param, &maxdim, &dummy);
RFsimu.cc://    printf("%d %d\n", maxdim, kc->truetimespacedim); 
RFsimu.cc:    if (maxdim < kc->truetimespacedim) return ERRORCOVNOTALLOWED;
RFsimu.cc:    kc->simugrid = // kc->param[ANISO] !!
RFsimu.cc:	grid && (!anisotropy || is_diag(&(kc->param[ANISO]), timespacedim));
RFsimu.cc:    if (kc->simugrid) {
RFsimu.cc:	    if ((kc->genuine_dim[d] = param[ANISO + n] != 0.0)) {
RFsimu.cc:		kc->idx[d] = ii++;
RFsimu.cc:		kc->idx[d] = kc->truetimespacedim + d - ii; 
RFsimu.cc:	    kc->genuine_dim[d] = true;
RFsimu.cc:	    kc->idx[d] = d;
RFsimu.cc:	kc->simugrid = false; // not programmed yet -- save version !!!!!!
RFsimu.cc:      error = cov->check(kc->param, kc->truetimespacedim, Nothing);
RFsimu.cc:    cov = &(CovList[kc->nr]);
RFsimu.cc://      memcpy(&(kc->param[ANISO]), &(keycov[v+1].param[ANISO]),
RFsimu.cc:  memcpy(&(kc->param[ANISO]), &(keycov[v+1].param[ANISO]),
RFsimu.cc:     GetTrueDim(anisotropy, timespacedim, kc->param,
RFsimu.cc:		&(kc->genuine_last_dimension), //
RFsimu.cc:		&(kc->truetimespacedim), kc->aniso);//
RFsimu.cc:     kc->aniso[0] = RF_NAN;
RFsimu.cc:    cov = &(CovList[kc->nr]);
RFsimu.cc:	v += (int) kc->param[HYPERNR];
RFsimu.cc:      if (CovList[kc->nr].cov == nugget && meth!=Nugget && ncov>1 &&
RFsimu.cc:	   kc->truetimespacedim < timespacedim)) {
RFsimu.cc:      key->active &= kc->method == meth;
RFsimu.cc:       cov = &(CovList[kc->nr]);
RFsimu.cc:       error=cov->check(kc->param, 2, TBM2);
RFsimu.cc:       kc->param[TBM2NUM] =
RFsimu.cc:      if (GENERAL_PRINTLEVEL > 1 && (kc->param[TBM2NUM]!=0.0))
RFsimu.cc:      if (kc->method >= (int) Nothing) {
RFsimu.cc://	printf("kc->method=%d %d %d \n", v, kc->method, (int) Nothing);
RFsimu.cc:      if (CovList[kc->nr].type == ISOHYPERMODEL || 
RFsimu.cc:	  CovList[kc->nr].type == ANISOHYPERMODEL) {
RFsimu.cc:	  int i, nc = (int) kc->param[HYPERNR];
RFsimu.cc:	      if (kc->method != key->cov[i].method) {
RFsimu.cc:      if (v>0 && op[v-1] && kc->method!=key->cov[v-1].method) {
RFsimu.cc:	  kc->method==CircEmbedIntrinsic) {
RFsimu.cc:      key->ML[v][0] = kc->method; 
RFsimu.cc:		kc->left = left[v];
RFsimu.cc://		if (kc->left) {
RFsimu.cc://		  if (kc->x != NULL) { free(kc->x); kc->x = NULL; }
RFsimu.cc:      if (kc->left) {
RFsimu.cc:	    PRINTF("'%s' not initiated yet\n", CovList[kc->nr].name);
RFsimu.cc:	    Merr = kc->method;
RFsimu.cc:	      kc->left = left[w];
RFsimu.cc://	      if (kc->left) {
RFsimu.cc:		   CovList[kc->nr].name);
RFspectral.cc:    if ((kc->method==SpectralTBM) && (kc->left)) {
RFspectral.cc:      timespacedim = kc->truetimespacedim;
RFspectral.cc:      assert((kc->nr >= 0) && (kc->nr < currentNrCov));
RFspectral.cc:      assert(kc->param[VARIANCE] >= 0.0);
RFspectral.cc:      cov = &(CovList[kc->nr]);
RFspectral.cc:      if ((Xerror=check_within_range(kc->param, cov, 2, " (spectral TBM)")) 
RFspectral.cc:	  (Xerror=cov->check(kc->param, timespacedim, SpectralTBM)) 
RFspectral.cc:	if (store_variance == kc->param[VARIANCE]) actcov++;
RFspectral.cc:	  kc->left=true;
RFspectral.cc:	store_variance = kc->param[VARIANCE];
RFspectral.cc:      kc->left = false;
RFspectral.cc:    assert((kc->truetimespacedim>=1) && (kc->truetimespacedim<=2));
RFspectral.cc:  sqrttwodivbyn = sqrt(kc->param[VARIANCE] * 2.0 / (double) SPECTRAL_LINES);
RFspectral.cc:    Amp= (s->randomAmplitude[v])(kc->param); 
RFspectral.cc:    if (kc->simugrid) {
RFspectral.cc://	  printf("%d %d \n", d, kc->length[d]);
RFspectral.cc:	if (kc->length[d] != 1) {
RFspectral.cc:	  segt += kc->x[XSTARTD[d]] * cossin[idxcossind];
RFspectral.cc:	  inc[d] = kc->x[XSTEPD[d]] * cossin[idxcossind++];
RFspectral.cc:      if (kc->truetimespacedim==1) {
RFspectral.cc:	  res[nx] += cos(cp * kc->x[nx] + VV);
RFspectral.cc:      } else { // kc->truetimespacedim==2 
RFspectral.cc:	  res[nx] += cos(cp * kc->x[twonx] + sp * kc->x[twonx+1] + VV);
RFtbm.cc:        cov = &(CovList[kc->nr]);
RFtbm.cc:	z[0] = kc->aniso[0] * x[0];
RFtbm.cc:	z[1] = kc->aniso[TBMTIME] * x[1];
RFtbm.cc:	  if (z[0]==0.0)  zw *= cov->cov(&(z[1]),  kc->param, dim); 
RFtbm.cc:	    zw *= TBM2integr(kc->nr, z[0], z[1], kc->param, 2, 2);
RFtbm.cc:	       zw *=  kc->param[VARIANCE] * z[0] / r *
RFtbm.cc:	       (cov->cov_tbm2(&r,  kc->param, dim) +
RFtbm.cc:	       TBM2integr_time(z[0] / r, r, cov->cov, kc->param, dim) );
RFtbm.cc:	  if (z[0]==0.0)  zw *= cov->cov(z, kc->param, 2);
RFtbm.cc:	  else if (kc->param[TBM2NUM] == 0.0) {
RFtbm.cc:	    zw *= cov->cov_tbm2(z, kc->param);
RFtbm.cc:	    zw *= TBM2integr(kc->nr, z[0], z[1], kc->param, 2,
RFtbm.cc:	zw *= kc->param[VARIANCE];	
RFtbm.cc:      cov = &(CovList[kc->nr]);
RFtbm.cc:      z = x[0] * kc->aniso[0];
RFtbm.cc:      else if (kc->param[TBM2NUM] == 0.0) {
RFtbm.cc:	zw = cov->cov_tbm2(&z, kc->param);
RFtbm.cc:	zw = TBM2integr(kc->nr, z, 0, kc->param, 2, cov->cov_tbm3 == NULL);
RFtbm.cc:      result += kc->param[VARIANCE] * zw;
RFtbm.cc:        cov = &(CovList[kc->nr]);
RFtbm.cc:	z[0] = kc->aniso[0] * x[0];
RFtbm.cc:	z[1] = kc->aniso[TBMTIME] * x[1];
RFtbm.cc:	  else abl[w] = kc->param[VARIANCE] * kc->aniso[0] * fabs(z[0]) / 
RFtbm.cc:		   r * cov->derivative(&r, kc->param);
RFtbm.cc:	  zw *= (fct[w] = kc->param[VARIANCE] * cov->cov(&r, kc->param, dim));
RFtbm.cc:	  abl[w] = kc->param[VARIANCE] * 
RFtbm.cc:	    kc->aniso[0] * cov->derivative(z, kc->param);
RFtbm.cc:	  zw *= (fct[w] = kc->param[VARIANCE] * cov->cov(z, kc->param, dim));
RFtbm.cc:    cov = &(CovList[kc->nr]);
RFtbm.cc:      z[0] = x[0] * kc->aniso[0];
RFtbm.cc:      return kc->param[VARIANCE] * cov->cov_tbm3(z, kc->param);
RFtbm.cc:    if ((kc->method==method) && (kc->left)) {
RFtbm.cc: 	ce_dim2 |= CovList[kc->nr].type==SPACEISOTROPIC ||
RFtbm.cc:	    kc->truetimespacedim == 1 + tbm_dim;
RFtbm.cc:	while (!ce_dim2 && (++v)<key->ncov && kc->op) {
RFtbm.cc:          ce_dim2 |= CovList[kc->nr].type==SPACEISOTROPIC;
RFtbm.cc:	  quot = kc->param[nonzero_pos] / first->param[nonzero_pos];
RFtbm.cc:	    if (fabs(first->param[w] * quot - kc->param[w]) >= 
RFtbm.cc:		(fabs(kc->param[w]) + (double)(kc->param[w]==0.0)) *
RFtbm.cc:	if (kc->truetimespacedim > tbm_dim) {
RFtbm.cc:    if ((kc->method==method) && (kc->left)) {
RFtbm.cc:      cov = &(CovList[kc->nr]);
RFtbm.cc:      assert((kc->nr>=0) && (kc->nr<currentNrCov));
RFtbm.cc:      assert(kc->param[VARIANCE]>=0.0);
RFtbm.cc:      if (v<key->ncov-1 && kc->op) {
RFtbm.cc:	  kc->left = true;
RFtbm.cc:      if ((Xerror=check_within_range(kc->param, cov, tbm_dim + (int) ce_dim2, 
RFtbm.cc:      Xerror=cov->check(kc->param, tbm_dim + (int) ce_dim2, method);
RFtbm.cc:      quot = kc->param[nonzero_pos] / first->param[nonzero_pos];
RFtbm.cc:        equal = fabs(first->param[w] * quot - kc->param[w])
RFtbm.cc:	    < (fabs(kc->param[w]) + (double)(kc->param[w]==0.0)) *
RFtbm.cc:	kc->left = true;
RFtbm.cc:      memcpy(&(ParamList[cum_nParam[actcov]]), kc->param, 
RFtbm.cc:      covnr[actcov] = kc->nr;
RFtbm.cc:      op[actcov] = kc->op;
RFtbm.cc:	  if (kc->param[w]!=0.0) {
RFtbm.cc:	ParamList[Aniso + 3] = kc->param[lasttimecomponent];
RFtbm.cc:	      if (kc->param[w] != 0.0) {
RFtbm.cc:	      if (spacecomponent_found = (kc->param[w]!=0.0)) break;
RFtbm.cc:      kc->left=false;
RFtbm.cc:    } // kc->left
RFtbm.cc:    newadditive = kc->op != 0;
